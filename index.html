<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Pixel Pet with Chores</title>
  <style>
    /* Reset and basic styling */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      font-size: 16px;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      background-color: #f0f8ff;
      transition: background-color 0.5s ease;
    }
    #root {
      width: 100%;
      height: 100%;
    }
    .app-container {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
    }
    .pet-area {
      position: relative;
      width: 100%;
      flex: 0 0 72%;
      overflow: hidden;
      background: linear-gradient(180deg, #a0d9ff 0%, #f0f8ff 100%);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .pet-name-input {
      position: absolute;
      top: 2%;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      padding: 1em;
      font-size: 2rem;
      border: none;
      border-bottom: 2px solid #ccc;
      text-align: center;
      background: rgba(255, 255, 255, 0.7);
      color: #333;
      outline: none;
      transition: background 0.3s;
    }
    .pet-name-input:focus {
      background: rgba(255, 255, 255, 0.9);
    }
    .controls-area {
      width: 100%;
      flex: 0 0 28%;
      background-color: rgba(255, 255, 255, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      grid-auto-rows: 1fr;
      gap: 1em;
      padding: 1em;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
    }
    .controls button {
      padding: 0;
      border: none;
      background-color: #007BFF;
      color: white;
      border-radius: 10px;
      cursor: pointer;
      font-size: 2.5rem;
      transition: background-color 0.3s, transform 0.2s;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 6px rgba(0, 123, 255, 0.3);
    }
    .controls button:hover {
      background-color: #0056b3;
      transform: translateY(-3px);
      box-shadow: 0 6px 8px rgba(0, 86, 179, 0.3);
    }
    .controls button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
      box-shadow: none;
    }
    /* Chore list styling */
    .chore-list {
      position: absolute;
      top: 5%;
      left: 50%;
      transform: translateX(-50%);
      width: 95%;
      max-height: 90%;
      overflow-y: auto;
      background: rgba(240, 248, 255, 0.95);
      padding: 1em;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }
    .chore-list h2 {
      text-align: center;
      margin-bottom: 1em;
      font-size: 2rem;
    }
    .chore-form {
      margin-bottom: 1em;
    }
    .chore-form input,
    .chore-form select {
      font-size: 1.5rem;
      padding: 0.5em;
      width: 100%;
      margin-bottom: 0.5em;
      border: 1px solid #ccc;
      border-radius: 5px;
    }
    .chore-form button {
      font-size: 1.5rem;
      padding: 0.5em 1em;
      width: 100%;
      background-color: #007BFF;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .chore-form button:hover {
      background-color: #0056b3;
    }
    .chore-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5em;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 0.5em;
      border-radius: 5px;
    }
    .chore-item span {
      font-size: 1.5rem;
      flex: 1;
    }
    .chore-item button {
      font-size: 1.5rem;
      padding: 0.5em 1em;
      margin-left: 0.5em;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .chore-item button.complete {
      background-color: #28a745;
      color: white;
    }
    .chore-item button.complete:hover {
      background-color: #218838;
    }
    .chore-item button.remove {
      background-color: #dc3545;
      color: white;
    }
    .chore-item button.remove:hover {
      background-color: #c82333;
    }
    .currency-display {
      position: absolute;
      top: 2%;
      right: 2%;
      font-size: 1.5rem;
      background: rgba(255, 255, 255, 0.7);
      padding: 0.5em 1em;
      border-radius: 5px;
    }
    /* Responsive styling */
    @media (max-width: 800px) {
      .pet-name-input {
        font-size: 1.5rem;
      }
      .controls {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      }
      .controls button {
        font-size: 2rem;
      }
      .chore-list {
        width: 95%;
        top: 5%;
      }
    }
    @media (max-width: 500px) {
      .controls {
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      }
      .controls button {
        font-size: 1.5rem;
      }
      .pet-name-input {
        font-size: 1.2rem;
      }
      .chore-form input,
      .chore-form select,
      .chore-form button {
        font-size: 1.2rem;
      }
      .chore-item span {
        font-size: 1.2rem;
      }
      .chore-item button {
        font-size: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <!-- Include React and Babel -->
  <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  <!-- Include Babel for JSX transpilation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Our script -->
  <script type="text/babel">
    function PixelPet() {
      const { useState, useEffect, useRef } = React;
      const [seed, setSeed] = useState(Math.random() * 10000);
      const [mood, setMood] = useState('happy');
      const [evolutionStage, setEvolutionStage] = useState(0);
      const [name, setName] = useState('');
      const [species] = useState(Math.floor(Math.random() * 3));
      const [animation, setAnimation] = useState('idle');
      const [position, setPosition] = useState({ x: 100, y: 100 });
      const [direction, setDirection] = useState({ x: 1, y: 1 });
      const [colorTheme, setColorTheme] = useState(0);
      const [showZzz, setShowZzz] = useState(false);
      const [isShaking, setIsShaking] = useState(false);
      const [isBouncing, setIsBouncing] = useState(false);
      const [poops, setPoops] = useState([]);
      const [currency, setCurrency] = useState(0);

      // Chore-related states
      const [chores, setChores] = useState([]);
      const [dailyChores, setDailyChores] = useState([]);
      const [showChoreList, setShowChoreList] = useState(false);
      const [newChore, setNewChore] = useState({
        name: '',
        frequency: 'daily',
        value: 1,
        excludeDays: 'none', // 'weekdays', 'weekends', 'none'
      });
      const [choresInitialized, setChoresInitialized] = useState(false);

      const evolutionStages = ['Egg', 'Child', 'Teen', 'Adult'];
      const colorThemes = ['Classic', 'Pastel', 'Neon', 'Monochrome'];
      const moods = ['happy', 'sad', 'sleepy', 'energetic'];

      const containerRef = useRef(null);
      const petRef = useRef(null);

      const cellSize = 8;
      const petWidth = 32 * cellSize;
      const petHeight = 32 * cellSize;

      useEffect(() => {
        document.body.className = mood;
      }, [mood]);

      // Cycle moods automatically
      useEffect(() => {
        const moodCycle = setInterval(() => {
          setMood(prevMood => {
            const nextMoodIndex = (moods.indexOf(prevMood) + 1) % moods.length;
            return moods[nextMoodIndex];
          });
        }, 10000); // Change mood every 10 seconds

        return () => clearInterval(moodCycle);
      }, []);

      useEffect(() => {
        const moodAnimations = {
          happy: 'bounce',
          sad: 'idle',
          sleepy: 'sleep',
          energetic: 'run',
        };
        setAnimation(moodAnimations[mood] || 'idle');

        setShowZzz(mood === 'sleepy');

        // Trigger bounce animation when happy
        if (mood === 'happy' && evolutionStage > 0) {
          setIsBouncing(true);
          setTimeout(() => setIsBouncing(false), 2000);
        }
      }, [mood, evolutionStage]);

      useEffect(() => {
        let animationFrame;
        const movePet = () => {
          setPosition((pos) => {
            const containerWidth = containerRef.current.offsetWidth;
            const containerHeight = containerRef.current.offsetHeight;

            let speed = animation === 'run' ? 4 : 1;
            let newX = pos.x + direction.x * speed;
            let newY = pos.y + direction.y * speed;

            // Check horizontal boundaries
            if (newX <= 0) {
              newX = 0;
              setDirection((dir) => ({ ...dir, x: Math.abs(dir.x) }));
            } else if (newX + petWidth >= containerWidth) {
              newX = containerWidth - petWidth;
              setDirection((dir) => ({ ...dir, x: -Math.abs(dir.x) }));
            }

            // Check vertical boundaries
            if (newY <= 0) {
              newY = 0;
              setDirection((dir) => ({ ...dir, y: Math.abs(dir.y) }));
            } else if (newY + petHeight >= containerHeight) {
              newY = containerHeight - petHeight;
              setDirection((dir) => ({ ...dir, y: -Math.abs(dir.y) }));
            }

            // Randomly change direction to simulate wandering
            if (animation === 'wander' && Math.random() < 0.01) {
              setDirection({
                x: Math.random() < 0.5 ? -1 : 1,
                y: Math.random() < 0.5 ? -1 : 1,
              });
            }

            return { x: newX, y: newY };
          });

          animationFrame = requestAnimationFrame(movePet);
        };

        if (animation === 'wander' || animation === 'run') {
          animationFrame = requestAnimationFrame(movePet);
        }

        return () => cancelAnimationFrame(animationFrame);
      }, [animation, direction]);

      // Egg shaking animation
      useEffect(() => {
        if (evolutionStage === 0) {
          const shakeInterval = setInterval(() => {
            setIsShaking(true);
            setTimeout(() => setIsShaking(false), 500);
          }, 5000); // Shake every 5 seconds

          return () => clearInterval(shakeInterval);
        }
      }, [evolutionStage]);

      // Pooping mechanic
      useEffect(() => {
        const poopInterval = setInterval(() => {
          if (evolutionStage > 0) {
            setPoops(prevPoops => [...prevPoops, generatePoop()]);
          }
        }, 15000); // Pet poops every 15 seconds

        return () => clearInterval(poopInterval);
      }, [evolutionStage, position]);

      const generatePoop = () => {
        return {
          id: Date.now() + Math.random(),
          x: position.x + petWidth / 2 + (Math.random() - 0.5) * 100,
          y: position.y + petHeight - 20,
        };
      };

      // Initialize daily chores after chore list is created
      useEffect(() => {
        if (chores.length > 0 && !choresInitialized) {
          generateDailyChores();
          setChoresInitialized(true);
        }
      }, [chores, choresInitialized]);

      // Function to generate daily chores
      const generateDailyChores = () => {
        const now = new Date();
        const dayOfWeek = now.getDay(); // 0 (Sunday) to 6 (Saturday)
        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;

        // Filter chores based on excludeDays
        const availableChores = chores.filter(chore => {
          if (chore.excludeDays === 'weekends' && isWeekend) return false;
          if (chore.excludeDays === 'weekdays' && !isWeekend) return false;
          return true;
        });

        // Sort chores by value
        const lowValueChores = availableChores.filter(chore => chore.value <= 3);
        const midValueChores = availableChores.filter(chore => chore.value > 3 && chore.value <= 6);
        const highValueChores = availableChores.filter(chore => chore.value > 6);

        // Randomly pick one from each category
        const getRandomChore = (choreArray) => {
          if (choreArray.length === 0) return null;
          return choreArray[Math.floor(Math.random() * choreArray.length)];
        };

        const selectedChores = [];
        const lowChore = getRandomChore(lowValueChores);
        const midChore = getRandomChore(midValueChores);
        const highChore = getRandomChore(highValueChores);

        if (lowChore) selectedChores.push(lowChore);
        if (midChore) selectedChores.push(midChore);
        if (highChore) selectedChores.push(highChore);

        setDailyChores(selectedChores);
      };

      // Safe grid functions
      const safeSetGrid = (grid, x, y, value) => {
        if (y >= 0 && y < grid.length && x >= 0 && x < grid[0].length) {
          grid[y][x] = value;
        }
      };

      const safeGetGrid = (grid, x, y) => {
        if (y >= 0 && y < grid.length && x >= 0 && x < grid[0].length) {
          return grid[y][x];
        }
        return null;
      };

      const generatePet = () => {
        const width = 32;
        const height = 32;
        const grid = Array(height).fill().map(() => Array(width).fill(0));

        let currentSeed = seed;
        const random = () => {
          const x = Math.sin(currentSeed++) * 10000;
          return x - Math.floor(x);
        };

        const getColors = () => {
          const hue = (colorTheme * 90 + random() * 60) % 360;
          const saturation = colorTheme === 3 ? '10%' : '70%';
          return {
            main: `hsl(${hue}, ${saturation}, ${50 + random() * 20}%)`,
            accent: `hsl(${(hue + 30) % 360}, ${saturation}, ${50 + random() * 20}%)`,
            detail: `hsl(${(hue + 60) % 360}, ${saturation}, ${50 + random() * 20}%)`
          };
        };

        const colors = getColors();

        const centerX = Math.floor(width / 2);
        const centerY = Math.floor(height / 2);

        const bodySize = 0.5 + (evolutionStage * 0.1);
        const bodyHeight = Math.floor(height * (bodySize + random() * 0.1));
        const bodyWidth = Math.floor(width * (bodySize + random() * 0.1));
        const bodyStartY = centerY - Math.floor(bodyHeight / 2);
        const bodyStartX = centerX - Math.floor(bodyWidth / 2);

        // Randomly generated features
        const features = {
          hasTail: evolutionStage >= 1 && random() > 0.5,
          hasWings: evolutionStage >= 2 && random() > 0.5,
          hasHorns: evolutionStage >= 2 && random() > 0.5,
          earType: evolutionStage >= 1 ? Math.floor(random() * 4) : -1,
          eyeType: Math.floor(random() * 4),
          mouthType: Math.floor(random() * 4),
          accessory: random() > 0.6 ? Math.floor(random() * 6) : -1,
          pattern: random() > 0.4,
        };

        // Generate body shape
        const bodyShapes = ['oval', 'round', 'square', 'blob', 'triangle', 'star', 'diamond', 'heart'];
        const bodyType = evolutionStage === 0 ? 'egg' : bodyShapes[Math.floor(random() * bodyShapes.length)];

        // Draw body
        for (let y = 0; y < bodyHeight; y++) {
          for (let x = 0; x < bodyWidth; x++) {
            let drawPixel = false;
            const nx = x - bodyWidth / 2;
            const ny = y - bodyHeight / 2;
            switch(bodyType) {
              case 'egg':
              case 'oval':
                drawPixel = (nx * nx) / ((bodyWidth / 2) ** 2) + (ny * ny) / ((bodyHeight / 2) ** 2) <= 1;
                break;
              case 'round':
                drawPixel = (nx * nx + ny * ny) <= (bodyWidth / 2) * (bodyHeight / 2) * 0.8;
                break;
              case 'square':
                drawPixel = true;
                break;
              case 'blob':
                drawPixel = random() > 0.2;
                break;
              case 'triangle':
                drawPixel = ny >= Math.abs(nx) * (bodyHeight / bodyWidth);
                break;
              case 'star':
                drawPixel = (Math.abs(nx * ny) < (bodyWidth * bodyHeight) / 10) || (Math.abs(nx) + Math.abs(ny) < bodyWidth / 3);
                break;
              case 'diamond':
                drawPixel = Math.abs(nx) + Math.abs(ny) <= bodyWidth / 2;
                break;
              case 'heart':
                const a = nx / (bodyWidth / 2);
                const b = ny / (bodyHeight / 2);
                drawPixel = Math.pow(a * a + b * b - 1, 3) - a * a * b * b * b <= 0;
                break;
            }
            if (drawPixel) {
              safeSetGrid(grid, bodyStartX + x, bodyStartY + y, 1);
            }
          }
        }

        // Egg stage has no face
        if (evolutionStage > 0) {
          // Draw face
          const faceY = bodyStartY + Math.floor(bodyHeight * 0.3);
          const eyeSpacing = 2 + evolutionStage;
          const eyeX1 = centerX - eyeSpacing;
          const eyeX2 = centerX + eyeSpacing;

          // Eyes
          switch(features.eyeType) {
            case 0: // Normal eyes
              safeSetGrid(grid, eyeX1, faceY, 2);
              safeSetGrid(grid, eyeX2, faceY, 2);
              break;
            case 1: // Big eyes
              safeSetGrid(grid, eyeX1, faceY, 2);
              safeSetGrid(grid, eyeX2, faceY, 2);
              safeSetGrid(grid, eyeX1, faceY - 1, 2);
              safeSetGrid(grid, eyeX2, faceY - 1, 2);
              break;
            case 2: // Slanted eyes
              safeSetGrid(grid, eyeX1 - 1, faceY, 2);
              safeSetGrid(grid, eyeX2 + 1, faceY, 2);
              break;
            case 3: // Closed eyes
              safeSetGrid(grid, eyeX1, faceY, 2);
              safeSetGrid(grid, eyeX1 + 1, faceY, 2);
              safeSetGrid(grid, eyeX2 - 1, faceY, 2);
              safeSetGrid(grid, eyeX2, faceY, 2);
              break;
          }

          // Mouth
          const mouthY = faceY + 4;
          switch(features.mouthType) {
            case 0: // Smile
              safeSetGrid(grid, centerX - 1, mouthY, 3);
              safeSetGrid(grid, centerX, mouthY + 1, 3);
              safeSetGrid(grid, centerX + 1, mouthY, 3);
              break;
            case 1: // Frown
              safeSetGrid(grid, centerX - 1, mouthY + 1, 3);
              safeSetGrid(grid, centerX, mouthY, 3);
              safeSetGrid(grid, centerX + 1, mouthY + 1, 3);
              break;
            case 2: // Open mouth
              safeSetGrid(grid, centerX - 1, mouthY, 3);
              safeSetGrid(grid, centerX, mouthY, 3);
              safeSetGrid(grid, centerX + 1, mouthY, 3);
              break;
            case 3: // O mouth
              safeSetGrid(grid, centerX, mouthY, 3);
              safeSetGrid(grid, centerX, mouthY + 1, 3);
              break;
          }

          // Ears
          const earY = bodyStartY - 2;
          switch(features.earType) {
            case 0: // Pointy ears
              safeSetGrid(grid, centerX - 3, earY, 1);
              safeSetGrid(grid, centerX + 3, earY, 1);
              break;
            case 1: // Round ears
              safeSetGrid(grid, centerX - 3, earY + 1, 1);
              safeSetGrid(grid, centerX + 3, earY + 1, 1);
              break;
            case 2: // Long ears
              safeSetGrid(grid, centerX - 2, earY - 1, 1);
              safeSetGrid(grid, centerX + 2, earY - 1, 1);
              safeSetGrid(grid, centerX - 2, earY, 1);
              safeSetGrid(grid, centerX + 2, earY, 1);
              break;
            case 3: // Antenna
              safeSetGrid(grid, centerX, earY - 2, 1);
              safeSetGrid(grid, centerX, earY - 1, 1);
              break;
          }

          // Horns
          if (features.hasHorns) {
            safeSetGrid(grid, centerX - 1, earY - 2, 1);
            safeSetGrid(grid, centerX + 1, earY - 2, 1);
          }

          // Wings
          if (features.hasWings) {
            for (let i = 0; i < 3; i++) {
              safeSetGrid(grid, centerX - Math.floor(bodyWidth / 2) - i, centerY + i, 1);
              safeSetGrid(grid, centerX + Math.floor(bodyWidth / 2) + i, centerY + i, 1);
            }
          }

          // Tail
          if (features.hasTail) {
            for (let i = 0; i < 4; i++) {
              safeSetGrid(grid, centerX, bodyStartY + bodyHeight + i, 1);
            }
          }

          // Accessories
          if (features.accessory !== -1) {
            const accessoryY = bodyStartY - 4;
            switch(features.accessory) {
              case 0: // Hat
                for (let x = -2; x <= 2; x++) {
                  safeSetGrid(grid, centerX + x, accessoryY, 4);
                }
                safeSetGrid(grid, centerX, accessoryY - 1, 4);
                break;
              case 1: // Bow
                safeSetGrid(grid, centerX - 2, accessoryY, 4);
                safeSetGrid(grid, centerX + 2, accessoryY, 4);
                safeSetGrid(grid, centerX, accessoryY + 1, 4);
                break;
              case 2: // Glasses
                for (let x = eyeX1 - 1; x <= eyeX2 + 1; x++) {
                  safeSetGrid(grid, x, faceY, 4);
                }
                safeSetGrid(grid, centerX, faceY, 4);
                break;
              case 3: // Scarf
                for (let x = -3; x <= 3; x++) {
                  safeSetGrid(grid, centerX + x, faceY + 5, 4);
                }
                break;
              case 4: // Necklace
                safeSetGrid(grid, centerX - 1, faceY + 6, 4);
                safeSetGrid(grid, centerX, faceY + 6, 4);
                safeSetGrid(grid, centerX + 1, faceY + 6, 4);
                break;
              case 5: // Flower
                safeSetGrid(grid, centerX - 3, accessoryY + 1, 4);
                safeSetGrid(grid, centerX - 3, accessoryY, 4);
                safeSetGrid(grid, centerX - 4, accessoryY + 1, 4);
                safeSetGrid(grid, centerX - 2, accessoryY + 1, 4);
                break;
            }
          }

          // Patterns or spots
          if (features.pattern) {
            for (let i = 0; i < 15; i++) {
              const x = bodyStartX + Math.floor(random() * bodyWidth);
              const y = bodyStartY + Math.floor(random() * bodyHeight);
              if (safeGetGrid(grid, x, y) === 1) {
                safeSetGrid(grid, x, y, 5);
              }
            }
          }
        }

        return (
          <svg
            ref={petRef}
            className={`${isShaking ? 'shake' : ''} ${isBouncing ? 'bounce' : ''}`}
            viewBox={`0 0 ${width * cellSize} ${height * cellSize}`}
            width={width * cellSize}
            height={height * cellSize}
            style={{
              position: 'absolute',
              left: position.x,
              top: position.y,
              transform: direction.x === -1 ? 'scaleX(-1)' : 'scaleX(1)',
            }}
          >
            {grid.map((row, y) =>
              row.map((cell, x) =>
                cell ? (
                  <rect
                    key={`${x}-${y}`}
                    x={x * cellSize}
                    y={y * cellSize}
                    width={cellSize}
                    height={cellSize}
                    fill={
                      cell === 1 ? colors.main :
                      cell === 2 ? 'black' :
                      cell === 3 ? 'black' :
                      cell === 4 ? colors.accent :
                      cell === 5 ? colors.detail :
                      'black'
                    }
                  />
                ) : null
              )
            )}
          </svg>
        );
      };

      // Handle adding a new chore
      const handleAddChore = () => {
        if (newChore.name.trim() === '') return;
        let value = parseInt(newChore.value);
        if (value < 1) value = 1;
        if (value > 10) value = 10;
        setChores([...chores, { ...newChore, value: value, id: Date.now(), lastCompleted: null }]);
        setNewChore({ name: '', frequency: 'daily', value: 1, excludeDays: 'none' });
      };

      // Handle completing a chore
      const handleCompleteChore = (choreId) => {
        const chore = dailyChores.find(chore => chore.id === choreId);
        if (chore) {
          setCurrency(currency + parseInt(chore.value));
          setDailyChores(dailyChores.filter(chore => chore.id !== choreId));
        }
      };

      // Remove a chore
      const handleRemoveChore = (choreId) => {
        setChores(chores.filter(chore => chore.id !== choreId));
      };

      return (
        <div className="app-container">
          <div className="pet-area" ref={containerRef}>
            <input
              placeholder="Name your pet"
              value={name}
              onChange={e => setName(e.target.value)}
              className="pet-name-input"
            />
            <div className="currency-display">
              Currency: {currency}
            </div>
            {generatePet()}
            {showZzz && (
              <div
                className="zzz"
                style={{
                  position: 'absolute',
                  left: position.x + petWidth / 2 - 20,
                  top: position.y - 30,
                }}
              >
                Zzz...
              </div>
            )}
            {/* Render poops */}
            {poops.map(poop => (
              <div
                key={poop.id}
                className="poop"
                style={{
                  position: 'absolute',
                  left: poop.x,
                  top: poop.y,
                  cursor: 'pointer',
                }}
                onClick={() => {
                  setPoops(prevPoops => prevPoops.filter(p => p.id !== poop.id));
                }}
              >
                💩
              </div>
            ))}
            {/* Chore List */}
            {showChoreList && (
              <div className="chore-list">
                <h2>Chore List</h2>
                {/* Add Chore Form */}
                <div className="chore-form">
                  <input
                    type="text"
                    placeholder="Chore Name"
                    value={newChore.name}
                    onChange={e => setNewChore({ ...newChore, name: e.target.value })}
                  />
                  <select
                    value={newChore.frequency}
                    onChange={e => setNewChore({ ...newChore, frequency: e.target.value })}
                  >
                    <option value="daily">Daily</option>
                    <option value="weekly">Weekly</option>
                    <option value="bi-weekly">Bi-Weekly</option>
                    <option value="monthly">Monthly</option>
                  </select>
                  <input
                    type="number"
                    placeholder="Value (1-10)"
                    value={newChore.value}
                    min="1"
                    max="10"
                    onChange={e => {
                      let value = parseInt(e.target.value);
                      if (value > 10) value = 10;
                      if (value < 1) value = 1;
                      setNewChore({ ...newChore, value: value });
                    }}
                  />
                  <select
                    value={newChore.excludeDays}
                    onChange={e => setNewChore({ ...newChore, excludeDays: e.target.value })}
                  >
                    <option value="none">Every Day</option>
                    <option value="weekends">Exclude Weekends</option>
                    <option value="weekdays">Exclude Weekdays</option>
                  </select>
                  <button onClick={handleAddChore}>
                    Add Chore
                  </button>
                </div>
                {/* Chore List Items */}
                {chores.map(chore => (
                  <div key={chore.id} className="chore-item">
                    <span>{chore.name} ({chore.frequency}) - {chore.value} pts</span>
                    <button className="remove" onClick={() => handleRemoveChore(chore.id)}>Remove</button>
                  </div>
                ))}
              </div>
            )}
            {/* Daily Chores */}
            {!showChoreList && choresInitialized && (
              <div className="chore-list">
                <h2>Today's Tasks</h2>
                {dailyChores.length > 0 ? (
                  dailyChores.map(chore => (
                    <div key={chore.id} className="chore-item">
                      <span>{chore.name} - {chore.value} pts</span>
                      <button className="complete" onClick={() => handleCompleteChore(chore.id)}>Done</button>
                    </div>
                  ))
                ) : (
                  <p>All chores completed for today!</p>
                )}
              </div>
            )}
          </div>
          <div className="controls-area">
            <div className="controls">
              <button>Pets</button>
              <button>Shop</button>
              <button onClick={() => setShowChoreList(!showChoreList)}>Chores</button>
              <button>Items</button>
            </div>
          </div>
        </div>
      );
    }

    // Render the component
    ReactDOM.render(<PixelPet />, document.getElementById('root'));
  </script>
</body>
</html>
