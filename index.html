<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Pixel Pet</title>
  <style>
    /* Basic styling for the app */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden; /* Prevent scrolling */
    }
    #root {
      width: 100%;
      height: 100%;
    }
    .app-container {
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      position: relative;
      background-color: #f0f8ff;
    }
    .controls {
      position: absolute;
      bottom: 0;
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 8px;
    }
    .controls button {
      padding: 10px 16px;
      border: none;
      background-color: #007BFF;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s;
      font-size: 14px;
    }
    .controls button:hover {
      background-color: #0056b3;
    }
    .controls button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .pet-name-input {
      position: absolute;
      top: 0;
      width: 100%;
      padding: 8px;
      box-sizing: border-box;
      border: none;
      border-bottom: 1px solid #ccc;
      font-size: 16px;
    }
    /* Mood-based background colors */
    body.happy {
      background-color: #e0ffe0;
    }
    body.sad {
      background-color: #ffe0e0;
    }
    body.sleepy {
      background-color: #e0e0ff;
    }
    body.energetic {
      background-color: #fff0e0;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <!-- Include React and Babel -->
  <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  <!-- Include Babel for JSX transpilation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Our script -->
  <script type="text/babel">
    function PixelPet() {
      const { useState, useEffect, useRef } = React;
      const [seed, setSeed] = useState(1);
      const [mood, setMood] = useState('happy');
      const [evolutionStage, setEvolutionStage] = useState(0);
      const [name, setName] = useState('');
      const [species] = useState(Math.floor(Math.random() * 3));
      const [animation, setAnimation] = useState('wander');
      const [position, setPosition] = useState({ x: 0, y: 0 });
      const [direction, setDirection] = useState(1);
      const [colorTheme, setColorTheme] = useState(0);
      const [soundEnabled, setSoundEnabled] = useState(false);

      const evolutionStages = ['Egg', 'Baby', 'Teen', 'Adult'];
      const colorThemes = ['Classic', 'Pastel', 'Neon', 'Monochrome'];
      const moods = ['happy', 'sad', 'sleepy', 'energetic'];

      const containerRef = useRef(null);

      useEffect(() => {
        document.body.className = mood;
      }, [mood]);

      useEffect(() => {
        const moodAnimations = {
          happy: 'wander',
          sad: 'idle',
          sleepy: 'sleep',
          energetic: 'run',
        };
        setAnimation(moodAnimations[mood] || 'idle');
      }, [mood]);

      useEffect(() => {
        let animationFrame;
        const movePet = () => {
          setPosition(pos => {
            const containerWidth = containerRef.current.offsetWidth;
            const containerHeight = containerRef.current.offsetHeight;
            let newX = pos.x;
            let newY = pos.y;

            if (animation === 'wander') {
              newX += direction * 1;
              if (newX > containerWidth - 50 || newX < 0) {
                setDirection(d => -d);
              }
            } else if (animation === 'run') {
              newX += direction * 4;
              if (newX > containerWidth - 50 || newX < 0) {
                setDirection(d => -d);
              }
            }

            return { x: newX, y: newY };
          });

          animationFrame = requestAnimationFrame(movePet);
        };

        animationFrame = requestAnimationFrame(movePet);

        return () => cancelAnimationFrame(animationFrame);
      }, [animation, direction]);

      const safeSetGrid = (grid, x, y, value) => {
        if (y >= 0 && y < grid.length && x >= 0 && x < grid[0].length) {
          grid[y][x] = value;
        }
      };

      const safeGetGrid = (grid, x, y) => {
        if (y >= 0 && y < grid.length && x >= 0 && x < grid[0].length) {
          return grid[y][x];
        }
        return null;
      };

      const playSound = (type) => {
        if (!soundEnabled) return;
        const sounds = {
          happy: 'https://example.com/happy.mp3',
          sad: 'https://example.com/sad.mp3',
          sleepy: 'https://example.com/sleepy.mp3',
          energetic: 'https://example.com/energetic.mp3',
        };
        const audio = new Audio(sounds[type]);
        audio.play();
      };

      const generatePet = (cellSize = 4) => {
        const width = 32;
        const height = 32;
        const grid = Array(height).fill().map(() => Array(width).fill(0));

        let currentSeed = seed;
        const random = () => {
          const x = Math.sin(currentSeed++) * 10000;
          return x - Math.floor(x);
        };

        const getColors = () => {
          const hue = (colorTheme * 90 + random() * 60) % 360;
          const saturation = colorTheme === 3 ? '10%' : '70%';
          return {
            main: `hsl(${hue}, ${saturation}, ${50 + random() * 20}%)`,
            accent: `hsl(${(hue + 30) % 360}, ${saturation}, ${50 + random() * 20}%)`,
            detail: `hsl(${(hue + 60) % 360}, ${saturation}, ${50 + random() * 20}%)`
          };
        };

        const colors = getColors();

        const centerX = Math.floor(width / 2);
        const centerY = Math.floor(height / 2);

        const bodySize = 0.5 + (evolutionStage * 0.1);
        const bodyHeight = Math.floor(height * (bodySize + random() * 0.1));
        const bodyWidth = Math.floor(width * (bodySize + random() * 0.1));
        const bodyStartY = centerY - Math.floor(bodyHeight / 2);
        const bodyStartX = centerX - Math.floor(bodyWidth / 2);

        // Randomly generated features
        const features = {
          hasTail: evolutionStage >= 1 && random() > 0.5,
          hasWings: evolutionStage >= 2 && random() > 0.5,
          hasHorns: evolutionStage >= 2 && random() > 0.5,
          earType: evolutionStage >= 1 ? Math.floor(random() * 3) : -1,
          eyeType: Math.floor(random() * 3),
          mouthType: Math.floor(random() * 3),
          accessory: random() > 0.7 ? Math.floor(random() * 5) : -1,
          pattern: random() > 0.5,
        };

        // Generate body shape
        const bodyShapes = ['oval', 'round', 'square', 'blob', 'triangle'];
        const bodyType = evolutionStage === 0 ? 'egg' : bodyShapes[Math.floor(random() * bodyShapes.length)];

        // Draw body
        for (let y = 0; y < bodyHeight; y++) {
          for (let x = 0; x < bodyWidth; x++) {
            let drawPixel = false;
            switch(bodyType) {
              case 'egg':
              case 'oval':
                drawPixel = Math.pow((x - bodyWidth / 2) / (bodyWidth / 2), 2) + Math.pow((y - bodyHeight / 2) / (bodyHeight / 2), 2) <= 1;
                break;
              case 'round':
                drawPixel = Math.pow((x - bodyWidth / 2) / (bodyWidth / 2), 2) + Math.pow((y - bodyHeight / 2) / (bodyHeight / 2), 2) <= 0.8;
                break;
              case 'square':
                drawPixel = true;
                break;
              case 'blob':
                drawPixel = random() > 0.2;
                break;
              case 'triangle':
                drawPixel = y >= x * (bodyHeight / bodyWidth) && y >= (bodyWidth - x - 1) * (bodyHeight / bodyWidth);
                break;
            }
            if (drawPixel) {
              safeSetGrid(grid, bodyStartX + x, bodyStartY + y, 1);
            }
          }
        }

        // Egg stage has no face
        if (evolutionStage > 0) {
          // Draw face
          const faceY = bodyStartY + Math.floor(bodyHeight * 0.3);
          const eyeSpacing = 2 + evolutionStage;
          const eyeX1 = centerX - eyeSpacing;
          const eyeX2 = centerX + eyeSpacing;

          // Eyes
          switch(features.eyeType) {
            case 0: // Normal eyes
              safeSetGrid(grid, eyeX1, faceY, 2);
              safeSetGrid(grid, eyeX2, faceY, 2);
              break;
            case 1: // Big eyes
              safeSetGrid(grid, eyeX1, faceY, 2);
              safeSetGrid(grid, eyeX2, faceY, 2);
              safeSetGrid(grid, eyeX1, faceY - 1, 2);
              safeSetGrid(grid, eyeX2, faceY - 1, 2);
              break;
            case 2: // Slanted eyes
              safeSetGrid(grid, eyeX1 - 1, faceY, 2);
              safeSetGrid(grid, eyeX2 + 1, faceY, 2);
              break;
          }

          // Mouth
          const mouthY = faceY + 3;
          switch(features.mouthType) {
            case 0: // Smile
              safeSetGrid(grid, centerX - 1, mouthY, 3);
              safeSetGrid(grid, centerX, mouthY + 1, 3);
              safeSetGrid(grid, centerX + 1, mouthY, 3);
              break;
            case 1: // Frown
              safeSetGrid(grid, centerX - 1, mouthY + 1, 3);
              safeSetGrid(grid, centerX, mouthY, 3);
              safeSetGrid(grid, centerX + 1, mouthY + 1, 3);
              break;
            case 2: // Open mouth
              safeSetGrid(grid, centerX - 1, mouthY, 3);
              safeSetGrid(grid, centerX, mouthY, 3);
              safeSetGrid(grid, centerX + 1, mouthY, 3);
              break;
          }

          // Ears
          const earY = bodyStartY - 2;
          if (features.earType === 0) {
            // Pointy ears
            safeSetGrid(grid, centerX - 3, earY, 1);
            safeSetGrid(grid, centerX + 3, earY, 1);
          } else if (features.earType === 1) {
            // Round ears
            safeSetGrid(grid, centerX - 3, earY + 1, 1);
            safeSetGrid(grid, centerX + 3, earY + 1, 1);
          } else if (features.earType === 2) {
            // Long ears
            safeSetGrid(grid, centerX - 2, earY - 1, 1);
            safeSetGrid(grid, centerX + 2, earY - 1, 1);
            safeSetGrid(grid, centerX - 2, earY, 1);
            safeSetGrid(grid, centerX + 2, earY, 1);
          }

          // Horns
          if (features.hasHorns) {
            safeSetGrid(grid, centerX - 1, earY - 2, 1);
            safeSetGrid(grid, centerX + 1, earY - 2, 1);
          }

          // Wings
          if (features.hasWings) {
            for (let i = 0; i < 3; i++) {
              safeSetGrid(grid, centerX - Math.floor(bodyWidth / 2) - i, centerY + i, 1);
              safeSetGrid(grid, centerX + Math.floor(bodyWidth / 2) + i, centerY + i, 1);
            }
          }

          // Tail
          if (features.hasTail) {
            for (let i = 0; i < 4; i++) {
              safeSetGrid(grid, centerX + Math.floor(bodyWidth / 2) + i, bodyStartY + bodyHeight - 2 - i, 1);
            }
          }

          // Accessories
          if (features.accessory !== -1) {
            const accessoryY = bodyStartY - 4;
            switch(features.accessory) {
              case 0: // Hat
                safeSetGrid(grid, centerX - 2, accessoryY, 4);
                safeSetGrid(grid, centerX - 1, accessoryY, 4);
                safeSetGrid(grid, centerX, accessoryY, 4);
                safeSetGrid(grid, centerX + 1, accessoryY, 4);
                safeSetGrid(grid, centerX + 2, accessoryY, 4);
                safeSetGrid(grid, centerX, accessoryY - 1, 4);
                break;
              case 1: // Bow
                safeSetGrid(grid, centerX - 2, accessoryY, 4);
                safeSetGrid(grid, centerX + 2, accessoryY, 4);
                safeSetGrid(grid, centerX, accessoryY + 1, 4);
                break;
              case 2: // Glasses
                safeSetGrid(grid, eyeX1 - 1, faceY, 4);
                safeSetGrid(grid, eyeX1, faceY, 4);
                safeSetGrid(grid, eyeX2, faceY, 4);
                safeSetGrid(grid, eyeX2 + 1, faceY, 4);
                safeSetGrid(grid, centerX, faceY, 4);
                break;
              case 3: // Scarf
                for (let x = -3; x <= 3; x++) {
                  safeSetGrid(grid, centerX + x, faceY + 5, 4);
                }
                break;
              case 4: // Necklace
                safeSetGrid(grid, centerX - 1, faceY + 6, 4);
                safeSetGrid(grid, centerX, faceY + 6, 4);
                safeSetGrid(grid, centerX + 1, faceY + 6, 4);
                break;
            }
          }

          // Patterns or spots
          if (features.pattern) {
            for (let i = 0; i < 10; i++) {
              const x = bodyStartX + Math.floor(random() * bodyWidth);
              const y = bodyStartY + Math.floor(random() * bodyHeight);
              if (safeGetGrid(grid, x, y) === 1) {
                safeSetGrid(grid, x, y, 5);
              }
            }
          }
        }

        return (
          <svg
            viewBox={`0 0 ${width * cellSize} ${height * cellSize}`}
            width={width * cellSize}
            height={height * cellSize}
            style={{
              position: 'absolute',
              left: position.x,
              top: position.y,
              transform: direction === -1 ? 'scaleX(-1)' : 'scaleX(1)',
            }}
          >
            {grid.map((row, y) =>
              row.map((cell, x) =>
                cell ? (
                  <rect
                    key={`${x}-${y}`}
                    x={x * cellSize}
                    y={y * cellSize}
                    width={cellSize}
                    height={cellSize}
                    fill={
                      cell === 1 ? colors.main :
                      cell === 2 ? 'black' :
                      cell === 3 ? 'black' :
                      cell === 4 ? colors.accent :
                      cell === 5 ? colors.detail :
                      'black'
                    }
                  />
                ) : null
              )
            )}
          </svg>
        );
      };

      return (
        <div className="app-container" ref={containerRef}>
          <input
            placeholder="Name your pet"
            value={name}
            onChange={e => setName(e.target.value)}
            className="pet-name-input"
          />
          {generatePet()}
          <div className="controls">
            <button onClick={() => { setSeed(Math.random() * 10000); playSound('happy'); }}>
              New Pet
            </button>
            <button onClick={() => {
              setMood(moods[(moods.indexOf(mood) + 1) % moods.length]);
              playSound(mood);
            }}>
              Mood
            </button>
            <button
              onClick={() => { setEvolutionStage(prev => Math.min(prev + 1, evolutionStages.length - 1)); playSound('happy'); }}
              disabled={evolutionStage === evolutionStages.length - 1}
            >
              Evolve
            </button>
            <button
              onClick={() => { setEvolutionStage(prev => Math.max(prev - 1, 0)); playSound('sad'); }}
              disabled={evolutionStage === 0}
            >
              Devolve
            </button>
            <button onClick={() => setColorTheme((colorTheme + 1) % colorThemes.length)}>
              {colorThemes[colorTheme]}
            </button>
            <button onClick={() => setSoundEnabled(!soundEnabled)}>
              {soundEnabled ? 'Sound On' : 'Sound Off'}
            </button>
          </div>
        </div>
      );
    }

    // Render the component
    ReactDOM.render(<PixelPet />, document.getElementById('root'));
  </script>
</body>
</html>
