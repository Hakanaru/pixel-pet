<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Pixel Pet</title>
  <style>
    /* Reset and basic styling */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f0f8ff;
    }
    #root {
      width: 100%;
      height: 100%;
    }
    .app-container {
      width: 100%;
      height: 100%;
      position: relative;
    }
    .pet-name-input {
      position: absolute;
      top: 2%;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      padding: 1em;
      font-size: 2em;
      border: none;
      border-bottom: 2px solid #ccc;
      text-align: center;
      background: transparent;
      color: #333;
    }
    .controls {
      position: absolute;
      bottom: 2%;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1em;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 1em;
      border-radius: 10px;
    }
    .controls button {
      padding: 1em 1.5em;
      border: none;
      background-color: #007BFF;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1.5em;
      transition: background-color 0.3s;
    }
    .controls button:hover {
      background-color: #0056b3;
    }
    .controls button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    /* Mood-based background colors */
    body.happy {
      background-color: #e0ffe0;
    }
    body.sad {
      background-color: #ffe0e0;
    }
    body.sleepy {
      background-color: #e0e0ff;
    }
    body.energetic {
      background-color: #fff0e0;
    }
    /* Poop styling */
    .poop {
      position: absolute;
      width: 50px;
      height: 50px;
      background: brown;
      border-radius: 50%;
      cursor: pointer;
    }
    /* Zzz styling for sleepy mood */
    .zzz {
      position: absolute;
      font-size: 3em;
      color: #333;
    }
    /* Responsive styling */
    @media (max-width: 600px) {
      .pet-name-input {
        font-size: 3em;
      }
      .controls button {
        font-size: 2.5em;
        padding: 1em 1.5em;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <!-- Include React and Babel -->
  <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  <!-- Include Babel for JSX transpilation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Our script -->
  <script type="text/babel">
    function PixelPet() {
      const { useState, useEffect, useRef } = React;
      const [pets, setPets] = useState(JSON.parse(localStorage.getItem('pets')) || []);
      const [currentPetIndex, setCurrentPetIndex] = useState(0);
      const [currentPet, setCurrentPet] = useState(pets[0] || null);
      const [name, setName] = useState(currentPet ? currentPet.name : '');
      const [poops, setPoops] = useState([]);
      const [showShop, setShowShop] = useState(false);
      const [balance, setBalance] = useState(parseInt(localStorage.getItem('balance')) || 0);
      const [chores, setChores] = useState(JSON.parse(localStorage.getItem('chores')) || []);
      const [completedChores, setCompletedChores] = useState(JSON.parse(localStorage.getItem('completedChores')) || []);
      const [showChoresModal, setShowChoresModal] = useState(false);
      const [isDeveloper, setIsDeveloper] = useState(false);
      const [animation, setAnimation] = useState('idle');
      const [showZzz, setShowZzz] = useState(false);

      const containerRef = useRef(null);

      // Save pets to localStorage whenever they change
      useEffect(() => {
        localStorage.setItem('pets', JSON.stringify(pets));
        if (pets.length > 0) {
          setCurrentPet(pets[currentPetIndex]);
        } else {
          setCurrentPet(null);
        }
      }, [pets, currentPetIndex]);

      // Save balance to localStorage
      useEffect(() => {
        localStorage.setItem('balance', balance);
      }, [balance]);

      // Save chores to localStorage
      useEffect(() => {
        localStorage.setItem('chores', JSON.stringify(chores));
        localStorage.setItem('completedChores', JSON.stringify(completedChores));
      }, [chores, completedChores]);

      // Initialize pet name and developer mode
      useEffect(() => {
        if (currentPet && currentPet.name === 'Hakanaru') {
          setIsDeveloper(true);
        } else {
          setIsDeveloper(false);
        }
      }, [currentPet]);

      // Pet mood and animations
      useEffect(() => {
        if (!currentPet) return;
        const mood = currentPet.mood;
        document.body.className = mood;

        // Handle animations based on mood
        switch (mood) {
          case 'happy':
            setAnimation('wander');
            setShowZzz(false);
            break;
          case 'sad':
            setAnimation('idle');
            setShowZzz(false);
            break;
          case 'sleepy':
            setAnimation('sleep');
            setShowZzz(true);
            break;
          case 'energetic':
            setAnimation('run');
            setShowZzz(false);
            break;
          default:
            setAnimation('idle');
            setShowZzz(false);
            break;
        }
      }, [currentPet]);

      // Pooping mechanic
      useEffect(() => {
        if (!currentPet) return;
        const poopInterval = setInterval(() => {
          // Random chance to poop every minute
          if (Math.random() < 0.1) {
            setPoops(prevPoops => [...prevPoops, generatePoop()]);
          }
        }, 60000); // Check every minute

        return () => clearInterval(poopInterval);
      }, [currentPet]);

      const generatePoop = () => {
        const containerWidth = containerRef.current.offsetWidth;
        const containerHeight = containerRef.current.offsetHeight;
        return {
          x: Math.random() * (containerWidth - 50),
          y: Math.random() * (containerHeight - 50),
          id: Date.now(),
        };
      };

      const cleanPoop = (id) => {
        setPoops(prevPoops => prevPoops.filter(poop => poop.id !== id));
        // Increase pet happiness or other stats
      };

      // Feeding mechanic
      const feedPet = () => {
        if (balance >= 5) {
          setBalance(balance - 5);
          // Increase pet stats
          alert('You fed your pet!');
        } else {
          alert('Not enough balance to feed your pet.');
        }
      };

      // Shop mechanic
      const openShop = () => {
        setShowShop(true);
      };

      const closeShop = () => {
        setShowShop(false);
      };

      const buyItem = (item) => {
        switch(item) {
          case 'Food':
            if (balance >= 5) {
              setBalance(balance - 5);
              // Add food to inventory or feed immediately
              alert('You bought food!');
            } else {
              alert('Not enough balance.');
            }
            break;
          case 'Progress Stone':
            if (balance >= 20) {
              setBalance(balance - 20);
              // Evolve pet
              evolvePet();
            } else {
              alert('Not enough balance.');
            }
            break;
          case 'Egg Stone':
            if (balance >= 50) {
              setBalance(balance - 50);
              // Add new pet
              initiateEggSelection();
            } else {
              alert('Not enough balance.');
            }
            break;
          default:
            break;
        }
      };

      const initiateEggSelection = () => {
        // Automatically start egg selection process
        selectEgg();
      };

      const selectEgg = () => {
        const eggOptions = ['Egg 1', 'Egg 2', 'Egg 3'];
        let chosenEgg = null;

        while (chosenEgg === null) {
          const choice = prompt('Choose an egg:\n1. Egg 1\n2. Egg 2\n3. Egg 3');
          const eggIndex = parseInt(choice) - 1;
          if (eggIndex >= 0 && eggIndex < 3) {
            chosenEgg = eggIndex;
          } else {
            alert('Invalid choice. Please select 1, 2, or 3.');
          }
        }

        const newPetName = prompt('Name your new pet:');
        if (newPetName !== null) {
          const newPet = {
            name: newPetName,
            stage: 0,
            mood: 'happy',
            lastEvolution: Date.now(),
            stats: {},
            seed: Math.random() * 10000 + chosenEgg * 1000,
          };
          setPets(prevPets => [...prevPets, newPet]);
          setCurrentPetIndex(pets.length);
          setCurrentPet(newPet);
          setName(newPetName);
        } else {
          alert('Pet creation canceled.');
        }
      };

      const evolvePet = () => {
        setPets(prevPets => {
          const updatedPets = [...prevPets];
          if (updatedPets[currentPetIndex].stage < 3) {
            updatedPets[currentPetIndex].stage += 1;
            updatedPets[currentPetIndex].lastEvolution = Date.now();
          }
          return updatedPets;
        });
      };

      // Chores management
      const openChoresModal = () => {
        setShowChoresModal(true);
      };

      const closeChoresModal = () => {
        setShowChoresModal(false);
      };

      const addChore = (chore) => {
        setChores(prevChores => [...prevChores, chore]);
      };

      const completeChore = (chore) => {
        setCompletedChores(prev => [...prev, { ...chore, date: new Date() }]);
        setBalance(balance + parseInt(chore.value));
        // Update pet stats or evolution
        checkEvolution();
      };

      const checkEvolution = () => {
        // Implement evolution logic based on completed chores
        const completionRate = calculateCompletionRate();
        const streak = calculateStreak();

        // Example logic
        if (completionRate > 80 && streak >= 7) {
          evolvePet();
        }
      };

      const calculateCompletionRate = () => {
        // Calculate the completion rate over the past week
        return 100; // Placeholder
      };

      const calculateStreak = () => {
        // Calculate the current streak of consecutive days with completed chores
        return 7; // Placeholder
      };

      // Rendering functions and components
      const renderPet = () => {
        if (!currentPet) {
          return null; // Do not render anything if no pet
        }

        // Pet rendering code (using generatePet function)
        const petSVG = generatePet(currentPet);

        return (
          <div style={{ position: 'relative' }}>
            {petSVG}
            {showZzz && <div className="zzz" style={{ left: '50%', top: '20%', transform: 'translateX(-50%)' }}>Zzz</div>}
            <h2 style={{ textAlign: 'center', fontSize: '2em' }}>
              {currentPet.name || 'Unnamed'} - {['Egg', 'Child', 'Teen', 'Adult'][currentPet.stage]}
            </h2>
          </div>
        );
      };

      const renderPoops = () => {
        return poops.map(poop => (
          <div
            key={poop.id}
            className="poop"
            style={{ left: poop.x, top: poop.y }}
            onClick={() => cleanPoop(poop.id)}
          ></div>
        ));
      };

      const renderShop = () => {
        if (!showShop) return null;
        return (
          <div style={{
            position: 'absolute',
            top: '10%',
            left: '10%',
            width: '80%',
            height: '80%',
            backgroundColor: 'white',
            border: '2px solid #ccc',
            borderRadius: '10px',
            padding: '1em',
            overflowY: 'auto',
            zIndex: 100,
          }}>
            <h2>Shop</h2>
            <p>Balance: {balance}</p>
            <ul>
              <li>
                Food - 5 points
                <button onClick={() => buyItem('Food')}>Buy</button>
              </li>
              <li>
                Progress Stone - 20 points
                <button onClick={() => buyItem('Progress Stone')}>Buy</button>
              </li>
              <li>
                Egg Stone - 50 points
                <button onClick={() => buyItem('Egg Stone')}>Buy</button>
              </li>
            </ul>
            <button onClick={closeShop}>Close</button>
          </div>
        );
      };

      const renderChoresModal = () => {
        if (!showChoresModal) return null;
        return (
          <div style={{
            position: 'absolute',
            top: '10%',
            left: '10%',
            width: '80%',
            height: '80%',
            backgroundColor: 'white',
            border: '2px solid #ccc',
            borderRadius: '10px',
            padding: '1em',
            overflowY: 'auto',
            zIndex: 100,
          }}>
            <h2>Chores</h2>
            <ul>
              {chores.map((chore, index) => (
                <li key={index}>
                  {chore.name} - {chore.frequency} - {chore.value} points
                  <button onClick={() => completeChore(chore)}>Complete</button>
                </li>
              ))}
            </ul>
            <button onClick={() => addChore(promptChore())}>Add Chore</button>
            <button onClick={closeChoresModal}>Close</button>
          </div>
        );
      };

      const promptChore = () => {
        const name = prompt('Enter chore name:');
        if (!name) return null;
        const frequency = prompt('Enter frequency (Daily, Weekly, etc.):');
        const value = prompt('Enter value (points):');
        return { name, frequency, value };
      };

      // Generate Pet Function (Updated to include features)
      const generatePet = (pet) => {
        const seed = pet.seed;
        const evolutionStage = pet.stage;
        const cellSize = 8; // Increased for larger size
        const width = 32;
        const height = 32;
        const grid = Array(height).fill().map(() => Array(width).fill(0));

        let currentSeed = seed;
        const random = () => {
          const x = Math.sin(currentSeed++) * 10000;
          return x - Math.floor(x);
        };

        const getColors = () => {
          const hue = (random() * 360) % 360;
          const saturation = '70%';
          return {
            main: `hsl(${hue}, ${saturation}, ${50 + random() * 20}%)`,
            accent: `hsl(${(hue + 30) % 360}, ${saturation}, ${50 + random() * 20}%)`,
            detail: `hsl(${(hue + 60) % 360}, ${saturation}, ${50 + random() * 20}%)`
          };
        };

        const colors = getColors();

        const centerX = Math.floor(width / 2);
        const centerY = Math.floor(height / 2);

        const bodySize = 0.5 + (evolutionStage * 0.1);
        const bodyHeight = Math.floor(height * (bodySize + random() * 0.1));
        const bodyWidth = Math.floor(width * (bodySize + random() * 0.1));
        const bodyStartY = centerY - Math.floor(bodyHeight / 2);
        const bodyStartX = centerX - Math.floor(bodyWidth / 2);

        // Randomly generated features
        const features = {
          hasTail: evolutionStage >= 1 && random() > 0.5,
          hasWings: evolutionStage >= 2 && random() > 0.5,
          hasHorns: evolutionStage >= 2 && random() > 0.5,
          earType: evolutionStage >= 1 ? Math.floor(random() * 4) : -1,
          eyeType: Math.floor(random() * 4),
          mouthType: Math.floor(random() * 4),
          accessory: random() > 0.6 ? Math.floor(random() * 6) : -1,
          pattern: random() > 0.4,
        };

        // Generate body shape
        const bodyShapes = ['oval', 'round', 'square', 'blob', 'triangle', 'star', 'diamond', 'heart'];
        const bodyType = evolutionStage === 0 ? 'egg' : bodyShapes[Math.floor(random() * bodyShapes.length)];

        // Draw body
        for (let y = 0; y < bodyHeight; y++) {
          for (let x = 0; x < bodyWidth; x++) {
            let drawPixel = false;
            const nx = x - bodyWidth / 2;
            const ny = y - bodyHeight / 2;
            switch(bodyType) {
              case 'egg':
              case 'oval':
                drawPixel = (nx * nx) / ((bodyWidth / 2) * (bodyWidth / 2)) + (ny * ny) / ((bodyHeight / 2) * (bodyHeight / 2)) <= 1;
                break;
              case 'round':
                drawPixel = (nx * nx + ny * ny) <= (bodyWidth / 2) * (bodyHeight / 2) * 0.8;
                break;
              case 'square':
                drawPixel = true;
                break;
              case 'blob':
                drawPixel = random() > 0.2;
                break;
              case 'triangle':
                drawPixel = y >= x * (bodyHeight / bodyWidth) && y >= (bodyWidth - x - 1) * (bodyHeight / bodyWidth);
                break;
              case 'star':
                drawPixel = Math.abs(nx * ny) < (bodyWidth * bodyHeight) / 10;
                break;
              case 'diamond':
                drawPixel = Math.abs(nx) + Math.abs(ny) <= bodyWidth / 2;
                break;
              case 'heart':
                const a = nx / (bodyWidth / 2);
                const b = ny / (bodyHeight / 2);
                drawPixel = (a * a + b * b - 1) ** 3 - a * a * b * b * b <= 0;
                break;
            }
            if (drawPixel) {
              safeSetGrid(grid, bodyStartX + x, bodyStartY + y, 1);
            }
          }
        }

        // Egg stage animations
        if (evolutionStage === 0) {
          // Implement egg shaking or bouncing animations here
        }

        // Egg stage has no face
        if (evolutionStage > 0) {
          // Draw face and features as before
          // ... (Same as previous code)
        }

        return (
          <svg
            viewBox={`0 0 ${width * cellSize} ${height * cellSize}`}
            width={width * cellSize}
            height={height * cellSize}
            style={{
              position: 'absolute',
              left: '50%',
              top: '40%',
              transform: 'translate(-50%, -50%)',
            }}
          >
            {grid.map((row, y) =>
              row.map((cell, x) =>
                cell ? (
                  <rect
                    key={`${x}-${y}`}
                    x={x * cellSize}
                    y={y * cellSize}
                    width={cellSize}
                    height={cellSize}
                    fill={
                      cell === 1 ? colors.main :
                      cell === 2 ? 'black' :
                      cell === 3 ? 'black' :
                      cell === 4 ? colors.accent :
                      cell === 5 ? colors.detail :
                      'black'
                    }
                  />
                ) : null
              )
            )}
          </svg>
        );
      };

      const safeSetGrid = (grid, x, y, value) => {
        if (y >= 0 && y < grid.length && x >= 0 && x < grid[0].length) {
          grid[y][x] = value;
        }
      };

      // Automatically start egg selection if no pets are saved
      useEffect(() => {
        if (!currentPet) {
          initiateEggSelection();
        }
      }, [currentPet]);

      return (
        <div className="app-container" ref={containerRef}>
          {currentPet && (
            <input
              placeholder="Name your pet"
              value={name}
              onChange={e => setName(e.target.value)}
              className="pet-name-input"
              onBlur={() => {
                setPets(prevPets => {
                  const updatedPets = [...prevPets];
                  updatedPets[currentPetIndex].name = name;
                  return updatedPets;
                });
              }}
            />
          )}
          {renderPet()}
          {renderPoops()}
          {renderShop()}
          {renderChoresModal()}
          <div className="controls">
            {currentPet && (
              <>
                <button onClick={openShop}>Shop</button>
                <button onClick={feedPet}>Feed</button>
                <button onClick={openChoresModal}>Chores</button>
                {isDeveloper && (
                  <>
                    <button onClick={evolvePet}>Evolve</button>
                    <button onClick={() => setBalance(balance + 100)}>Add Balance</button>
                    <button onClick={addNewPet}>Add Pet</button>
                  </>
                )}
              </>
            )}
          </div>
        </div>
      );
    }

    // Render the component
    ReactDOM.render(<PixelPet />, document.getElementById('root'));
  </script>
</body>
</html>
