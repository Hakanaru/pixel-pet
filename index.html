<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Pixel Pet with Chores</title>
  <style>
    /* Reset and basic styling */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      font-size: 16px;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      background-color: #f0f8ff;
      transition: background-color 0.5s ease;
    }
    #root {
      width: 100%;
      height: 100%;
    }
    .app-container {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
    }
    .pet-area {
      position: relative;
      width: 100%;
      flex: 0 0 72%;
      overflow: hidden;
      background: linear-gradient(180deg, #a0d9ff 0%, #f0f8ff 100%);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .pet-name-input {
      position: absolute;
      top: 2%;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      padding: 1em;
      font-size: 2.5rem;
      border: none;
      border-bottom: 2px solid #ccc;
      text-align: center;
      background: rgba(255, 255, 255, 0.7);
      color: #333;
      outline: none;
      transition: background 0.3s;
    }
    .pet-name-input:focus {
      background: rgba(255, 255, 255, 0.9);
    }
    .controls-area {
      width: 100%;
      flex: 0 0 28%;
      background-color: rgba(255, 255, 255, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      grid-auto-rows: 1fr;
      gap: 1em;
      padding: 1em;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
    }
    .controls button {
      padding: 0;
      border: none;
      background-color: #007BFF;
      color: white;
      border-radius: 10px;
      cursor: pointer;
      font-size: 2rem;
      transition: background-color 0.3s, transform 0.2s;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 6px rgba(0, 123, 255, 0.3);
    }
    .controls button:hover {
      background-color: #0056b3;
      transform: translateY(-3px);
      box-shadow: 0 6px 8px rgba(0, 86, 179, 0.3);
    }
    .controls button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
      box-shadow: none;
    }
    /* Modal styling */
    .modal {
      position: absolute;
      top: 25%; /* Adjusted to be 20% lower */
      left: 50%;
      transform: translateX(-50%);
      width: 95%;
      max-height: 70%; /* Adjusted for new top position */
      overflow-y: auto;
      background: rgba(240, 248, 255, 0.95);
      padding: 1em;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }
    .modal h2 {
      text-align: center;
      margin-bottom: 1em;
      font-size: 2.5rem;
    }
    .modal .close-button {
      position: absolute;
      top: 10px;
      right: 20px;
      font-size: 2rem;
      background: none;
      border: none;
      cursor: pointer;
    }
    .modal .close-button:hover {
      color: red;
    }
    .chore-form {
      margin-bottom: 1em;
    }
    .chore-form input,
    .chore-form select {
      font-size: 1.5rem;
      padding: 0.5em;
      width: 100%;
      margin-bottom: 0.5em;
      border: 1px solid #ccc;
      border-radius: 5px;
    }
    .chore-form button {
      font-size: 1.5rem;
      padding: 0.5em 1em;
      width: 100%;
      background-color: #007BFF;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .chore-form button:hover {
      background-color: #0056b3;
    }
    .chore-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5em;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 0.5em;
      border-radius: 5px;
    }
    .chore-item span {
      font-size: 1.5rem;
      flex: 1;
    }
    .chore-item button {
      font-size: 1.5rem;
      padding: 0.5em 1em;
      margin-left: 0.5em;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .chore-item button.complete {
      background-color: #28a745;
      color: white;
    }
    .chore-item button.complete:hover {
      background-color: #218838;
    }
    .chore-item button.remove {
      background-color: #dc3545;
      color: white;
    }
    .chore-item button.remove:hover {
      background-color: #c82333;
    }
    .currency-display {
      position: absolute;
      top: 2%;
      right: 2%;
      font-size: 2rem;
      background: rgba(255, 255, 255, 0.7);
      padding: 0.5em 1em;
      border-radius: 5px;
    }
    .progress-bar,
    .hunger-bar {
      position: absolute;
      bottom: 2%;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      height: 30px;
      background-color: #ddd;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }
    .progress-bar {
      bottom: 5%; /* Slightly above hunger bar */
    }
    .progress-bar-inner {
      height: 100%;
      background: linear-gradient(90deg, #28a745, #8bc34a);
      width: 0%;
      transition: width 0.5s ease;
    }
    .hunger-bar-inner {
      height: 100%;
      background: linear-gradient(90deg, #ff5722, #ffc107);
      width: 0%;
      transition: width 0.5s ease;
    }
    /* Animation for chore completion */
    .chore-complete-animation {
      position: absolute;
      font-size: 3rem;
      color: #ffeb3b;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      animation: popUp 1s forwards;
    }
    @keyframes popUp {
      0% {
        opacity: 1;
        transform: translateY(0);
      }
      100% {
        opacity: 0;
        transform: translateY(-50px);
      }
    }
    /* Fix for pet movement artifacts */
    svg {
      position: absolute;
      will-change: transform;
    }
    /* Additional styling for items and pets */
    .inventory-item,
    .pet-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.5em;
      padding: 0.5em;
      background-color: rgba(255, 255, 255, 0.9);
      border-radius: 5px;
    }
    .inventory-item span,
    .pet-item span {
      font-size: 1.5rem;
    }
    .inventory-item button,
    .pet-item button {
      font-size: 1.5rem;
      padding: 0.5em 1em;
      margin-left: 0.5em;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .inventory-item button.use {
      background-color: #28a745;
      color: white;
    }
    .inventory-item button.use:hover {
      background-color: #218838;
    }
    .inventory-item button.discard {
      background-color: #dc3545;
      color: white;
    }
    .inventory-item button.discard:hover {
      background-color: #c82333;
    }
    /* Poop styling */
    .poop {
      font-size: 8rem; /* Increased size */
      position: absolute;
      cursor: pointer;
    }
    /* Egg selection */
    .egg-selection {
      display: flex;
      justify-content: space-around;
      align-items: center;
    }
    .egg-option {
      cursor: pointer;
    }
    /* Responsive styling */
    @media (max-width: 800px) {
      .pet-name-input {
        font-size: 2rem;
      }
      .controls {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      }
      .controls button {
        font-size: 2rem;
      }
      .modal {
        width: 95%;
        top: 25%;
      }
    }
    @media (max-width: 500px) {
      .controls {
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      }
      .controls button {
        font-size: 1.5rem;
      }
      .pet-name-input {
        font-size: 1.5rem;
      }
      .chore-form input,
      .chore-form select,
      .chore-form button {
        font-size: 1.2rem;
      }
      .chore-item span {
        font-size: 1.2rem;
      }
      .chore-item button {
        font-size: 1.2rem;
      }
      .poop {
        font-size: 6rem;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <!-- Include React and Babel -->
  <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  <!-- Include Babel for JSX transpilation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Our script -->
  <script type="text/babel">
    function PixelPet() {
      const { useState, useEffect, useRef } = React;
      const [seed, setSeed] = useState(Math.random() * 10000);
      const [mood, setMood] = useState('happy');
      const [evolutionStage, setEvolutionStage] = useState(0);
      const [name, setName] = useState('');
      const [species] = useState(Math.floor(Math.random() * 3));
      const [animation, setAnimation] = useState('idle');
      const [position, setPosition] = useState({ x: 100, y: 100 });
      const [direction, setDirection] = useState({ x: 1, y: 1 });
      const [colorTheme, setColorTheme] = useState(0);
      const [showZzz, setShowZzz] = useState(false);
      const [isShaking, setIsShaking] = useState(false);
      const [isBouncing, setIsBouncing] = useState(false);
      const [poops, setPoops] = useState([]);
      const [currency, setCurrency] = useState(0);
      const [evolutionProgress, setEvolutionProgress] = useState(0);
      const [completedDays, setCompletedDays] = useState(0);

      // Hunger mechanic
      const [hunger, setHunger] = useState(100); // Hunger bar percentage
      const [neglectCounter, setNeglectCounter] = useState(0);

      // Chore-related states
      const [chores, setChores] = useState([]);
      const [dailyChores, setDailyChores] = useState([]);
      const [showChoreList, setShowChoreList] = useState(false);
      const [newChore, setNewChore] = useState({
        name: '',
        frequency: 'daily',
        value: 1,
        excludeDays: 'none',
      });
      const [showCompletionAnimation, setShowCompletionAnimation] = useState(false);

      // Shop-related states
      const [showShop, setShowShop] = useState(false);
      const [inventory, setInventory] = useState({
        food: 0,
        progressionStone: 0,
        petStone: 0,
      });

      // Items modal state
      const [showItems, setShowItems] = useState(false);

      // Tasks modal state
      const [showTasks, setShowTasks] = useState(false);

      // Pets modal state
      const [showPets, setShowPets] = useState(false);
      const [pets, setPets] = useState([]);
      const [currentPetId, setCurrentPetId] = useState(null);

      // Egg selection state
      const [showEggSelection, setShowEggSelection] = useState(false);
      const [eggOptions, setEggOptions] = useState([]);
      const [selectedEgg, setSelectedEgg] = useState(null);
      const [nameInput, setNameInput] = useState('');

      const evolutionStages = ['Egg', 'Child', 'Teen', 'Adult'];
      const moods = ['happy', 'sad', 'sleepy', 'energetic', 'hungry'];

      const containerRef = useRef(null);
      const petRef = useRef(null);

      const cellSize = 8;
      const petWidth = 32 * cellSize;
      const petHeight = 32 * cellSize;

      useEffect(() => {
        document.body.className = mood;
      }, [mood]);

      // Load data from localStorage
      useEffect(() => {
        const savedData = JSON.parse(localStorage.getItem('pixelPetData'));
        if (savedData) {
          setName(savedData.name);
          setCurrency(savedData.currency);
          setChores(savedData.chores);
          setEvolutionProgress(savedData.evolutionProgress);
          setEvolutionStage(savedData.evolutionStage);
          setCompletedDays(savedData.completedDays);
          setInventory(savedData.inventory);
          setPets(savedData.pets);
          setCurrentPetId(savedData.currentPetId);
          setHunger(savedData.hunger || 100);
          setNeglectCounter(savedData.neglectCounter || 0);
        } else {
          // If no pet exists, start egg selection
          handleAdoptNewPet();
        }
      }, []);

      // Save data to localStorage
      useEffect(() => {
        const dataToSave = {
          name,
          currency,
          chores,
          evolutionProgress,
          evolutionStage,
          completedDays,
          inventory,
          pets,
          currentPetId,
          hunger,
          neglectCounter,
        };
        localStorage.setItem('pixelPetData', JSON.stringify(dataToSave));
      }, [
        name,
        currency,
        chores,
        evolutionProgress,
        evolutionStage,
        completedDays,
        inventory,
        pets,
        currentPetId,
        hunger,
        neglectCounter,
      ]);

      // Cycle moods automatically
      useEffect(() => {
        const moodCycle = setInterval(() => {
          if (hunger < 20) {
            setMood('hungry');
          } else if (mood !== 'sleepy') {
            setMood('happy');
          }
        }, 5000); // Check mood every 5 seconds

        return () => clearInterval(moodCycle);
      }, [hunger, mood]);

      useEffect(() => {
        const moodAnimations = {
          happy: 'bounce',
          sad: 'idle',
          sleepy: 'sleep',
          energetic: 'run',
          hungry: 'hungry',
        };
        setAnimation(moodAnimations[mood] || 'idle');

        setShowZzz(mood === 'sleepy');

        // Trigger bounce animation when happy
        if (mood === 'happy' && evolutionStage > 0) {
          setIsBouncing(true);
          setTimeout(() => setIsBouncing(false), 2000);
        }
      }, [mood, evolutionStage]);

      useEffect(() => {
        let animationFrame;
        const movePet = () => {
          setPosition((pos) => {
            const containerWidth = containerRef.current.offsetWidth;
            const containerHeight = containerRef.current.offsetHeight;

            let speed = animation === 'run' ? 4 : mood === 'hungry' ? 0.5 : 1;
            let newX = pos.x + direction.x * speed;
            let newY = pos.y + direction.y * speed;

            // Check horizontal boundaries
            if (newX <= 0) {
              newX = 0;
              setDirection((dir) => ({ ...dir, x: Math.abs(dir.x) }));
            } else if (newX + petWidth >= containerWidth) {
              newX = containerWidth - petWidth;
              setDirection((dir) => ({ ...dir, x: -Math.abs(dir.x) }));
            }

            // Check vertical boundaries
            if (newY <= 0) {
              newY = 0;
              setDirection((dir) => ({ ...dir, y: Math.abs(dir.y) }));
            } else if (newY + petHeight >= containerHeight) {
              newY = containerHeight - petHeight;
              setDirection((dir) => ({ ...dir, y: -Math.abs(dir.y) }));
            }

            // Randomly change direction to simulate wandering
            if (animation === 'wander' && Math.random() < 0.01) {
              setDirection({
                x: Math.random() < 0.5 ? -1 : 1,
                y: Math.random() < 0.5 ? -1 : 1,
              });
            }

            return { x: newX, y: newY };
          });

          animationFrame = requestAnimationFrame(movePet);
        };

        if (animation === 'wander' || animation === 'run' || mood === 'hungry') {
          animationFrame = requestAnimationFrame(movePet);
        }

        return () => cancelAnimationFrame(animationFrame);
      }, [animation, direction, mood]);

      // Egg shaking animation
      useEffect(() => {
        if (evolutionStage === 0) {
          const shakeInterval = setInterval(() => {
            setIsShaking(true);
            setTimeout(() => setIsShaking(false), 500);
          }, 5000); // Shake every 5 seconds

          return () => clearInterval(shakeInterval);
        }
      }, [evolutionStage]);

      // Pooping mechanic
      useEffect(() => {
        if (hunger >= 100) {
          setPoops((prevPoops) => [...prevPoops, generatePoop()]);
          setHunger(80); // Reduce hunger after pooping
        }
      }, [hunger]);

      const generatePoop = () => {
        const safeY = position.y + petHeight + 10;
        return {
          id: Date.now() + Math.random(),
          x: position.x + petWidth / 2 + (Math.random() - 0.5) * 100,
          y: safeY > containerRef.current.offsetHeight - 50 ? containerRef.current.offsetHeight - 50 : safeY,
        };
      };

      // Hunger decreases over time
      useEffect(() => {
        const hungerInterval = setInterval(() => {
          setHunger((prevHunger) => {
            const newHunger = prevHunger - 5;
            if (newHunger <= 0) {
              setNeglectCounter((prev) => prev + 1);
              return 0;
            }
            return newHunger;
          });
        }, 10000); // Decrease hunger every 10 seconds

        return () => clearInterval(hungerInterval);
      }, []);

      // Neglect effects
      useEffect(() => {
        const neglectInterval = setInterval(() => {
          if (hunger <= 20 || poops.length > 0) {
            setEvolutionProgress((prev) => prev - 5);
            if (evolutionProgress <= 0 && evolutionStage > 0) {
              setEvolutionStage((prev) => prev - 1);
              setEvolutionProgress(100);
            } else if (evolutionStage === 0 && neglectCounter >= 5) {
              // Pet dies
              setPets(pets.filter((pet) => pet.id !== currentPetId));
              setCurrentPetId(null);
              handleAdoptNewPet();
            }
          }
        }, 15000); // Check neglect every 15 seconds

        return () => clearInterval(neglectInterval);
      }, [hunger, poops, evolutionProgress, evolutionStage, neglectCounter, pets, currentPetId]);

      // Function to generate daily chores
      useEffect(() => {
        generateDailyChores();
      }, [chores]);

      const generateDailyChores = () => {
        const now = new Date();
        const dayOfWeek = now.getDay(); // 0 (Sunday) to 6 (Saturday)
        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;

        // Filter chores based on excludeDays and frequency
        const availableChores = chores.filter((chore) => {
          if (chore.excludeDays === 'weekends' && isWeekend) return false;
          if (chore.excludeDays === 'weekdays' && !isWeekend) return false;

          // Handle frequency
          const lastCompleted = new Date(chore.lastCompleted || 0);
          const diffTime = Math.abs(now - lastCompleted);
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

          switch (chore.frequency) {
            case 'daily':
              return true;
            case 'weekly':
              return diffDays >= 7;
            case 'bi-weekly':
              return diffDays >= 14;
            case 'monthly':
              return diffDays >= 30;
            default:
              return true;
          }
        });

        setDailyChores(availableChores);
      };

      // Safe grid functions
      const safeSetGrid = (grid, x, y, value) => {
        if (y >= 0 && y < grid.length && x >= 0 && x < grid[0].length) {
          grid[y][x] = value;
        }
      };

      const safeGetGrid = (grid, x, y) => {
        if (y >= 0 && y < grid.length && x >= 0 && x < grid[0].length) {
          return grid[y][x];
        }
        return null;
      };

      const generatePet = () => {
        const width = 32;
        const height = 32;
        const grid = Array(height)
          .fill()
          .map(() => Array(width).fill(0));

        let currentSeed = seed;
        const random = () => {
          const x = Math.sin(currentSeed++) * 10000;
          return x - Math.floor(x);
        };

        const getColors = () => {
          const hue = (colorTheme * 90 + random() * 60) % 360;
          const saturation = colorTheme === 3 ? '10%' : '70%';
          return {
            main: `hsl(${hue}, ${saturation}, ${50 + random() * 20}%)`,
            accent: `hsl(${(hue + 30) % 360}, ${saturation}, ${
              50 + random() * 20
            }%)`,
            detail: `hsl(${(hue + 60) % 360}, ${saturation}, ${
              50 + random() * 20
            }%)`,
          };
        };

        const colors = getColors();

        const centerX = Math.floor(width / 2);
        const centerY = Math.floor(height / 2);

        const bodySize = 0.5 + evolutionStage * 0.1;
        const bodyHeight = Math.floor(height * (bodySize + random() * 0.1));
        const bodyWidth = Math.floor(width * (bodySize + random() * 0.1));
        const bodyStartY = centerY - Math.floor(bodyHeight / 2);
        const bodyStartX = centerX - Math.floor(bodyWidth / 2);

        // Randomly generated features
        const features = {
          hasTail: evolutionStage >= 1 && random() > 0.5,
          hasWings: evolutionStage >= 2 && random() > 0.5,
          hasHorns: evolutionStage >= 2 && random() > 0.5,
          earType: evolutionStage >= 1 ? Math.floor(random() * 4) : -1,
          eyeType: Math.floor(random() * 4),
          mouthType: Math.floor(random() * 4),
          accessory: random() > 0.6 ? Math.floor(random() * 6) : -1,
          pattern: random() > 0.4,
        };

        // Generate body shape
        const bodyShapes = [
          'oval',
          'round',
          'square',
          'blob',
          'triangle',
          'star',
          'diamond',
          'heart',
        ];
        const bodyType =
          evolutionStage === 0
            ? 'egg'
            : bodyShapes[Math.floor(random() * bodyShapes.length)];

        // Draw body
        for (let y = 0; y < bodyHeight; y++) {
          for (let x = 0; x < bodyWidth; x++) {
            let drawPixel = false;
            const nx = x - bodyWidth / 2;
            const ny = y - bodyHeight / 2;
            switch (bodyType) {
              case 'egg':
              case 'oval':
                drawPixel =
                  (nx * nx) / (bodyWidth / 2) ** 2 +
                    (ny * ny) / (bodyHeight / 2) ** 2 <=
                  1;
                break;
              case 'round':
                drawPixel =
                  nx * nx + ny * ny <=
                  (bodyWidth / 2) * (bodyHeight / 2) * 0.8;
                break;
              case 'square':
                drawPixel = true;
                break;
              case 'blob':
                drawPixel = random() > 0.2;
                break;
              case 'triangle':
                drawPixel = ny >= Math.abs(nx) * (bodyHeight / bodyWidth);
                break;
              case 'star':
                drawPixel =
                  Math.abs(nx * ny) < (bodyWidth * bodyHeight) / 10 ||
                  Math.abs(nx) + Math.abs(ny) < bodyWidth / 3;
                break;
              case 'diamond':
                drawPixel = Math.abs(nx) + Math.abs(ny) <= bodyWidth / 2;
                break;
              case 'heart':
                const a = nx / (bodyWidth / 2);
                const b = ny / (bodyHeight / 2);
                drawPixel =
                  Math.pow(a * a + b * b - 1, 3) - a * a * b * b * b <= 0;
                break;
            }
            if (drawPixel) {
              safeSetGrid(grid, bodyStartX + x, bodyStartY + y, 1);
            }
          }
        }

        // Egg stage has no face
        if (evolutionStage > 0) {
          // Draw face
          const faceY = bodyStartY + Math.floor(bodyHeight * 0.3);
          const eyeSpacing = 2 + evolutionStage;
          const eyeX1 = centerX - eyeSpacing;
          const eyeX2 = centerX + eyeSpacing;

          // Eyes
          switch (features.eyeType) {
            case 0: // Normal eyes
              safeSetGrid(grid, eyeX1, faceY, 2);
              safeSetGrid(grid, eyeX2, faceY, 2);
              break;
            case 1: // Big eyes
              safeSetGrid(grid, eyeX1, faceY, 2);
              safeSetGrid(grid, eyeX2, faceY, 2);
              safeSetGrid(grid, eyeX1, faceY - 1, 2);
              safeSetGrid(grid, eyeX2, faceY - 1, 2);
              break;
            case 2: // Slanted eyes
              safeSetGrid(grid, eyeX1 - 1, faceY, 2);
              safeSetGrid(grid, eyeX2 + 1, faceY, 2);
              break;
            case 3: // Closed eyes
              safeSetGrid(grid, eyeX1, faceY, 2);
              safeSetGrid(grid, eyeX1 + 1, faceY, 2);
              safeSetGrid(grid, eyeX2 - 1, faceY, 2);
              safeSetGrid(grid, eyeX2, faceY, 2);
              break;
          }

          // Mouth
          const mouthY = faceY + 4;
          switch (features.mouthType) {
            case 0: // Smile
              safeSetGrid(grid, centerX - 1, mouthY, 3);
              safeSetGrid(grid, centerX, mouthY + 1, 3);
              safeSetGrid(grid, centerX + 1, mouthY, 3);
              break;
            case 1: // Frown
              safeSetGrid(grid, centerX - 1, mouthY + 1, 3);
              safeSetGrid(grid, centerX, mouthY, 3);
              safeSetGrid(grid, centerX + 1, mouthY + 1, 3);
              break;
            case 2: // Open mouth
              safeSetGrid(grid, centerX - 1, mouthY, 3);
              safeSetGrid(grid, centerX, mouthY, 3);
              safeSetGrid(grid, centerX + 1, mouthY, 3);
              break;
            case 3: // O mouth
              safeSetGrid(grid, centerX, mouthY, 3);
              safeSetGrid(grid, centerX, mouthY + 1, 3);
              break;
          }

          // Ears
          const earY = bodyStartY - 2;
          switch (features.earType) {
            case 0: // Pointy ears
              safeSetGrid(grid, centerX - 3, earY, 1);
              safeSetGrid(grid, centerX + 3, earY, 1);
              break;
            case 1: // Round ears
              safeSetGrid(grid, centerX - 3, earY + 1, 1);
              safeSetGrid(grid, centerX + 3, earY + 1, 1);
              break;
            case 2: // Long ears
              safeSetGrid(grid, centerX - 2, earY - 1, 1);
              safeSetGrid(grid, centerX + 2, earY - 1, 1);
              safeSetGrid(grid, centerX - 2, earY, 1);
              safeSetGrid(grid, centerX + 2, earY, 1);
              break;
            case 3: // Antenna
              safeSetGrid(grid, centerX, earY - 2, 1);
              safeSetGrid(grid, centerX, earY - 1, 1);
              break;
          }

          // Horns
          if (features.hasHorns) {
            safeSetGrid(grid, centerX - 1, earY - 2, 1);
            safeSetGrid(grid, centerX + 1, earY - 2, 1);
          }

          // Wings
          if (features.hasWings) {
            for (let i = 0; i < 3; i++) {
              safeSetGrid(
                grid,
                centerX - Math.floor(bodyWidth / 2) - i,
                centerY + i,
                1
              );
              safeSetGrid(
                grid,
                centerX + Math.floor(bodyWidth / 2) + i,
                centerY + i,
                1
              );
            }
          }

          // Tail
          if (features.hasTail) {
            for (let i = 0; i < 4; i++) {
              safeSetGrid(grid, centerX, bodyStartY + bodyHeight + i, 1);
            }
          }

          // Accessories
          if (features.accessory !== -1) {
            const accessoryY = bodyStartY - 4;
            switch (features.accessory) {
              case 0: // Hat
                for (let x = -2; x <= 2; x++) {
                  safeSetGrid(grid, centerX + x, accessoryY, 4);
                }
                safeSetGrid(grid, centerX, accessoryY - 1, 4);
                break;
              case 1: // Bow
                safeSetGrid(grid, centerX - 2, accessoryY, 4);
                safeSetGrid(grid, centerX + 2, accessoryY, 4);
                safeSetGrid(grid, centerX, accessoryY + 1, 4);
                break;
              case 2: // Glasses
                for (let x = eyeX1 - 1; x <= eyeX2 + 1; x++) {
                  safeSetGrid(grid, x, faceY, 4);
                }
                safeSetGrid(grid, centerX, faceY, 4);
                break;
              case 3: // Scarf
                for (let x = -3; x <= 3; x++) {
                  safeSetGrid(grid, centerX + x, faceY + 5, 4);
                }
                break;
              case 4: // Necklace
                safeSetGrid(grid, centerX - 1, faceY + 6, 4);
                safeSetGrid(grid, centerX, faceY + 6, 4);
                safeSetGrid(grid, centerX + 1, faceY + 6, 4);
                break;
              case 5: // Flower
                safeSetGrid(grid, centerX - 3, accessoryY + 1, 4);
                safeSetGrid(grid, centerX - 3, accessoryY, 4);
                safeSetGrid(grid, centerX - 4, accessoryY + 1, 4);
                safeSetGrid(grid, centerX - 2, accessoryY + 1, 4);
                break;
            }
          }

          // Patterns or spots
          if (features.pattern) {
            for (let i = 0; i < 15; i++) {
              const x = bodyStartX + Math.floor(random() * bodyWidth);
              const y = bodyStartY + Math.floor(random() * bodyHeight);
              if (safeGetGrid(grid, x, y) === 1) {
                safeSetGrid(grid, x, y, 5);
              }
            }
          }
        }

        return (
          <svg
            ref={petRef}
            className={`${isShaking ? 'shake' : ''} ${
              isBouncing ? 'bounce' : ''
            }`}
            viewBox={`0 0 ${width * cellSize} ${height * cellSize}`}
            width={width * cellSize}
            height={height * cellSize}
            style={{
              position: 'absolute',
              left: position.x,
              top: position.y,
              transform: direction.x === -1 ? 'scaleX(-1)' : 'scaleX(1)',
            }}
          >
            {grid.map((row, y) =>
              row.map((cell, x) =>
                cell ? (
                  <rect
                    key={`${x}-${y}`}
                    x={x * cellSize}
                    y={y * cellSize}
                    width={cellSize}
                    height={cellSize}
                    fill={
                      cell === 1
                        ? colors.main
                        : cell === 2
                        ? 'black'
                        : cell === 3
                        ? 'black'
                        : cell === 4
                        ? colors.accent
                        : cell === 5
                        ? colors.detail
                        : 'black'
                    }
                  />
                ) : null
              )
            )}
          </svg>
        );
      };

      // Handle adding a new chore
      const handleAddChore = () => {
        if (newChore.name.trim() === '') return;
        let value = parseInt(newChore.value);
        if (value < 1) value = 1;
        if (value > 10) value = 10;
        setChores([
          ...chores,
          { ...newChore, value: value, id: Date.now(), lastCompleted: null },
        ]);
        setNewChore({
          name: '',
          frequency: 'daily',
          value: 1,
          excludeDays: 'none',
        });
      };

      // Handle completing a chore
      const handleCompleteChore = (choreId) => {
        const chore = dailyChores.find((chore) => chore.id === choreId);
        if (chore) {
          const extraProgress = chore.value * 15; // Increased progression
          setCurrency(currency + parseInt(chore.value) * 2); // Increased value
          setDailyChores(dailyChores.filter((chore) => chore.id !== choreId));
          setEvolutionProgress(evolutionProgress + extraProgress);
          setShowCompletionAnimation(true);
          setTimeout(() => setShowCompletionAnimation(false), 1000);
          checkEvolution();
          checkDailyCompletion();

          // Update lastCompleted date
          setChores(
            chores.map((c) =>
              c.id === chore.id ? { ...c, lastCompleted: new Date() } : c
            )
          );
        }
      };

      // Handle completing a chore from the chore list
      const handleCompleteChoreFromList = (choreId) => {
        setChores(
          chores.map((chore) =>
            chore.id === choreId
              ? { ...chore, lastCompleted: new Date() }
              : chore
          )
        );
        setEvolutionProgress(
          evolutionProgress +
            parseInt(chores.find((chore) => chore.id === choreId).value) * 10
        );
        setShowCompletionAnimation(true);
        setTimeout(() => setShowCompletionAnimation(false), 1000);
        checkEvolution();
        checkDailyCompletion();
      };

      // Check for evolution
      const checkEvolution = () => {
        if (evolutionProgress >= 100 && evolutionStage < evolutionStages.length - 1) {
          setEvolutionStage(evolutionStage + 1);
          setEvolutionProgress(0);
        }
      };

      // Check daily completion for egg evolution
      const checkDailyCompletion = () => {
        const today = new Date().toDateString();
        const lastCompletionDate = localStorage.getItem('lastCompletionDate');
        if (lastCompletionDate !== today) {
          setCompletedDays(completedDays + 1);
          localStorage.setItem('lastCompletionDate', today);
        }
        if (completedDays >= 2 && evolutionStage === 0) {
          setEvolutionStage(1); // Evolve from egg after 2 days
        }
      };

      // Remove a chore
      const handleRemoveChore = (choreId) => {
        setChores(chores.filter((chore) => chore.id !== choreId));
      };

      // Handle Shop purchases
      const handlePurchase = (item, quantity) => {
        const itemCosts = {
          food: 1,
          progressionStone: 10,
          petStone: 20,
        };
        const totalCost = itemCosts[item] * quantity;
        if (currency >= totalCost) {
          setCurrency(currency - totalCost);
          setInventory({
            ...inventory,
            [item]: inventory[item] + quantity,
          });
        } else {
          alert('Not enough currency!');
        }
      };

      // Use Item
      const handleUseItem = (item) => {
        if (inventory[item] > 0) {
          if (item === 'food') {
            setMood('happy');
            setHunger(hunger + 50 > 100 ? 100 : hunger + 50);
          } else if (item === 'progressionStone') {
            setEvolutionProgress(evolutionProgress + 20);
            checkEvolution();
          } else if (item === 'petStone') {
            handleAdoptNewPet();
          }
          setInventory({
            ...inventory,
            [item]: inventory[item] - 1,
          });
        }
      };

      // Adopt a new pet
      const handleAdoptNewPet = () => {
        setShowEggSelection(true);
        const eggs = [];
        for (let i = 0; i < 3; i++) {
          eggs.push({
            id: Date.now() + i,
            seed: Math.random() * 10000,
            colorTheme: Math.floor(Math.random() * 4),
          });
        }
        setEggOptions(eggs);
      };

      // Confirm adoption
      const confirmAdoption = () => {
        if (selectedEgg && nameInput.trim() !== '') {
          const newPet = {
            id: selectedEgg.id,
            name: nameInput,
            seed: selectedEgg.seed,
            evolutionStage: 0,
            evolutionProgress: 0,
            mood: 'happy',
            colorTheme: selectedEgg.colorTheme,
          };
          setPets([...pets, newPet]);
          setCurrentPetId(newPet.id);
          // Update pet states
          setSeed(newPet.seed);
          setEvolutionStage(newPet.evolutionStage);
          setEvolutionProgress(newPet.evolutionProgress);
          setMood(newPet.mood);
          setColorTheme(newPet.colorTheme);
          setName(newPet.name);
          setShowEggSelection(false);
          setNameInput('');
          setSelectedEgg(null);
        }
      };

      // Switch to a different pet
      const switchPet = (petId) => {
        const pet = pets.find((p) => p.id === petId);
        if (pet) {
          setCurrentPetId(petId);
          setSeed(pet.seed);
          setEvolutionStage(pet.evolutionStage);
          setEvolutionProgress(pet.evolutionProgress);
          setMood(pet.mood);
          setColorTheme(pet.colorTheme);
          setName(pet.name);
        }
      };

      // Update current pet's data
      useEffect(() => {
        setPets(
          pets.map((pet) =>
            pet.id === currentPetId
              ? {
                  ...pet,
                  name,
                  seed,
                  evolutionStage,
                  evolutionProgress,
                  mood,
                  colorTheme,
                }
              : pet
          )
        );
      }, [name, seed, evolutionStage, evolutionProgress, mood, colorTheme]);

      return (
        <div className="app-container">
          <div className="pet-area" ref={containerRef}>
            <input
              placeholder="Name your pet"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="pet-name-input"
            />
            <div className="currency-display">Currency: {currency}</div>
            {generatePet()}
            {showZzz && (
              <div
                className="zzz"
                style={{
                  position: 'absolute',
                  left: position.x + petWidth / 2 - 20,
                  top: position.y - 30,
                  fontSize: '2rem',
                }}
              >
                Zzz...
              </div>
            )}
            {/* Render poops */}
            {poops.map((poop) => (
              <div
                key={poop.id}
                className="poop"
                style={{
                  left: poop.x,
                  top: poop.y,
                }}
                onClick={() => {
                  setPoops((prevPoops) =>
                    prevPoops.filter((p) => p.id !== poop.id)
                  );
                }}
              >
                ðŸ’©
              </div>
            ))}
            {/* Progress Bar */}
            <div className="progress-bar">
              <div
                className="progress-bar-inner"
                style={{ width: `${evolutionProgress}%` }}
              ></div>
            </div>
            {/* Hunger Bar */}
            <div className="hunger-bar">
              <div
                className="hunger-bar-inner"
                style={{ width: `${hunger}%` }}
              ></div>
            </div>
            {/* Completion Animation */}
            {showCompletionAnimation && (
              <div
                className="chore-complete-animation"
                style={{
                  left: '50%',
                  top: '50%',
                  transform: 'translate(-50%, -50%)',
                }}
              >
                + Points!
              </div>
            )}
            {/* Chore List */}
            {showChoreList && (
              <div className="modal">
                <h2>Chore List</h2>
                <button
                  className="close-button"
                  onClick={() => setShowChoreList(false)}
                >
                  &times;
                </button>
                {/* Add Chore Form */}
                <div className="chore-form">
                  <input
                    type="text"
                    placeholder="Chore Name"
                    value={newChore.name}
                    onChange={(e) =>
                      setNewChore({ ...newChore, name: e.target.value })
                    }
                  />
                  <select
                    value={newChore.frequency}
                    onChange={(e) =>
                      setNewChore({ ...newChore, frequency: e.target.value })
                    }
                  >
                    <option value="daily">Daily</option>
                    <option value="weekly">Weekly</option>
                    <option value="bi-weekly">Bi-Weekly</option>
                    <option value="monthly">Monthly</option>
                  </select>
                  <input
                    type="number"
                    placeholder="Value (1-10)"
                    value={newChore.value}
                    min="1"
                    max="10"
                    onChange={(e) => {
                      let value = parseInt(e.target.value);
                      if (value > 10) value = 10;
                      if (value < 1) value = 1;
                      setNewChore({ ...newChore, value: value });
                    }}
                  />
                  <select
                    value={newChore.excludeDays}
                    onChange={(e) =>
                      setNewChore({ ...newChore, excludeDays: e.target.value })
                    }
                  >
                    <option value="none">Every Day</option>
                    <option value="weekends">Exclude Weekends</option>
                    <option value="weekdays">Exclude Weekdays</option>
                  </select>
                  <button onClick={handleAddChore}>Add Chore</button>
                </div>
                {/* Chore List Items */}
                {chores.map((chore) => (
                  <div key={chore.id} className="chore-item">
                    <span>
                      {chore.name} ({chore.frequency}) - {chore.value} pts
                    </span>
                    <button
                      className="complete"
                      onClick={() => handleCompleteChoreFromList(chore.id)}
                    >
                      Complete
                    </button>
                    <button
                      className="remove"
                      onClick={() => handleRemoveChore(chore.id)}
                    >
                      Remove
                    </button>
                  </div>
                ))}
              </div>
            )}
            {/* Tasks Modal */}
            {showTasks && (
              <div className="modal">
                <h2>Daily Tasks</h2>
                <button
                  className="close-button"
                  onClick={() => setShowTasks(false)}
                >
                  &times;
                </button>
                {dailyChores.length > 0 ? (
                  dailyChores.map((chore) => (
                    <div key={chore.id} className="chore-item">
                      <span>
                        {chore.name} - {chore.value * 2} pts
                      </span>
                      <button
                        className="complete"
                        onClick={() => handleCompleteChore(chore.id)}
                      >
                        Done
                      </button>
                    </div>
                  ))
                ) : (
                  <p>All chores completed for today!</p>
                )}
              </div>
            )}
            {/* Shop Modal */}
            {showShop && (
              <div className="modal">
                <h2>Shop</h2>
                <button
                  className="close-button"
                  onClick={() => setShowShop(false)}
                >
                  &times;
                </button>
                {['food', 'progressionStone', 'petStone'].map((item) => (
                  <div key={item} className="chore-item">
                    <span>
                      {item === 'food'
                        ? 'Food'
                        : item === 'progressionStone'
                        ? 'Progression Stone'
                        : 'Pet Stone'}{' '}
                      -{' '}
                      {item === 'food' ? 1 : item === 'progressionStone' ? 10 : 20}{' '}
                      pts each
                    </span>
                    <input
                      type="number"
                      min="1"
                      defaultValue="1"
                      style={{ width: '60px', fontSize: '1.5rem' }}
                      id={`quantity-${item}`}
                    />
                    <button
                      className="complete"
                      onClick={() =>
                        handlePurchase(
                          item,
                          parseInt(
                            document.getElementById(`quantity-${item}`).value
                          )
                        )
                      }
                    >
                      Buy
                    </button>
                  </div>
                ))}
              </div>
            )}
            {/* Items Modal */}
            {showItems && (
              <div className="modal">
                <h2>Inventory</h2>
                <button
                  className="close-button"
                  onClick={() => setShowItems(false)}
                >
                  &times;
                </button>
                {Object.keys(inventory).map((item) => (
                  <div key={item} className="inventory-item">
                    <span>
                      {item === 'food'
                        ? 'Food'
                        : item === 'progressionStone'
                        ? 'Progression Stone'
                        : 'Pet Stone'}{' '}
                      - {inventory[item]}
                    </span>
                    <button
                      className="use"
                      onClick={() => handleUseItem(item)}
                    >
                      Use
                    </button>
                  </div>
                ))}
              </div>
            )}
            {/* Pets Modal */}
            {showPets && (
              <div className="modal">
                <h2>Your Pets</h2>
                <button
                  className="close-button"
                  onClick={() => setShowPets(false)}
                >
                  &times;
                </button>
                {pets.map((pet) => (
                  <div key={pet.id} className="pet-item">
                    <span>{pet.name}</span>
                    <button
                      className="use"
                      onClick={() => switchPet(pet.id)}
                      disabled={pet.id === currentPetId}
                    >
                      {pet.id === currentPetId ? 'Current' : 'Switch'}
                    </button>
                  </div>
                ))}
              </div>
            )}
            {/* Egg Selection Modal */}
            {showEggSelection && (
              <div className="modal">
                <h2>Select an Egg</h2>
                <div className="egg-selection">
                  {eggOptions.map((egg) => (
                    <div
                      key={egg.id}
                      className="egg-option"
                      onClick={() => setSelectedEgg(egg)}
                    >
                      {generateEgg(egg)}
                    </div>
                  ))}
                </div>
                {selectedEgg && (
                  <div style={{ marginTop: '1em' }}>
                    <input
                      type="text"
                      placeholder="Name your pet"
                      value={nameInput}
                      onChange={(e) => setNameInput(e.target.value)}
                      style={{ fontSize: '1.5rem', width: '100%', padding: '0.5em' }}
                    />
                    <button
                      onClick={confirmAdoption}
                      style={{ fontSize: '1.5rem', width: '100%', padding: '0.5em', marginTop: '0.5em' }}
                    >
                      Confirm
                    </button>
                  </div>
                )}
              </div>
            )}
          </div>
          <div className="controls-area">
            <div className="controls">
              <button onClick={() => setShowPets(!showPets)}>Pets</button>
              <button onClick={() => setShowShop(!showShop)}>Shop</button>
              <button onClick={() => setShowChoreList(!showChoreList)}>Chores</button>
              <button onClick={() => setShowItems(!showItems)}>Items</button>
              <button onClick={() => setShowTasks(!showTasks)}>Tasks</button>
            </div>
          </div>
        </div>
      );

      function generateEgg(egg) {
        const width = 32;
        const height = 32;
        const grid = Array(height)
          .fill()
          .map(() => Array(width).fill(0));

        let currentSeed = egg.seed;
        const random = () => {
          const x = Math.sin(currentSeed++) * 10000;
          return x - Math.floor(x);
        };

        const getColors = () => {
          const hue = (egg.colorTheme * 90 + random() * 60) % 360;
          const saturation = egg.colorTheme === 3 ? '10%' : '70%';
          return {
            main: `hsl(${hue}, ${saturation}, ${50 + random() * 20}%)`,
            accent: `hsl(${(hue + 30) % 360}, ${saturation}, ${
              50 + random() * 20
            }%)`,
            detail: `hsl(${(hue + 60) % 360}, ${saturation}, ${
              50 + random() * 20
            }%)`,
          };
        };

        const colors = getColors();

        const centerX = Math.floor(width / 2);
        const centerY = Math.floor(height / 2);

        const bodyHeight = Math.floor(height * 0.5);
        const bodyWidth = Math.floor(width * 0.5);
        const bodyStartY = centerY - Math.floor(bodyHeight / 2);
        const bodyStartX = centerX - Math.floor(bodyWidth / 2);

        // Draw egg shape
        for (let y = 0; y < bodyHeight; y++) {
          for (let x = 0; x < bodyWidth; x++) {
            let drawPixel = false;
            const nx = x - bodyWidth / 2;
            const ny = y - bodyHeight / 2;
            drawPixel =
              (nx * nx) / (bodyWidth / 2) ** 2 +
                (ny * ny) / (bodyHeight / 2) ** 2 <=
              1;
            if (drawPixel) {
              safeSetGrid(grid, bodyStartX + x, bodyStartY + y, 1);
            }
          }
        }

        return (
          <svg
            viewBox={`0 0 ${width * cellSize} ${height * cellSize}`}
            width={width * cellSize}
            height={height * cellSize}
          >
            {grid.map((row, y) =>
              row.map((cell, x) =>
                cell ? (
                  <rect
                    key={`${x}-${y}`}
                    x={x * cellSize}
                    y={y * cellSize}
                    width={cellSize}
                    height={cellSize}
                    fill={
                      cell === 1
                        ? colors.main
                        : cell === 2
                        ? 'black'
                        : cell === 3
                        ? 'black'
                        : cell === 4
                        ? colors.accent
                        : cell === 5
                        ? colors.detail
                        : 'black'
                    }
                  />
                ) : null
              )
            )}
          </svg>
        );
      }
    }

    // Render the component
    ReactDOM.render(<PixelPet />, document.getElementById('root'));
  </script>
</body>
</html>
