<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Pixel Pet</title>
  <style>
    /* Reset and basic styling */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      font-size: 16px; /* Base font size */
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden; /* Prevent scrolling */
      background-color: #f0f8ff;
    }
    #root {
      width: 100%;
      height: 100%;
    }
    .app-container {
      width: 100%;
      height: 100%;
      position: relative;
    }
    .pet-name-input {
      position: absolute;
      top: 2%;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      padding: 1em;
      font-size: 1.5rem;
      border: none;
      border-bottom: 2px solid #ccc;
      text-align: center;
      background: transparent;
      color: #333;
    }
    .controls {
      position: absolute;
      bottom: 2%;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5em;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 1em;
      border-radius: 10px;
      max-width: 90%;
    }
    .controls button {
      padding: 0.8em 1.2em;
      border: none;
      background-color: #007BFF;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1rem;
      transition: background-color 0.3s;
      flex: 1 1 calc(33% - 1em);
      max-width: calc(33% - 1em);
    }
    .controls button:hover {
      background-color: #0056b3;
    }
    .controls button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    /* Mood-based background colors */
    body.happy {
      background-color: #e0ffe0;
    }
    body.sad {
      background-color: #ffe0e0;
    }
    body.sleepy {
      background-color: #e0e0ff;
    }
    body.energetic {
      background-color: #fff0e0;
    }
    /* Zzz styling */
    .zzz {
      font-size: 2rem;
      color: #333;
      animation: floatZzz 2s infinite;
    }
    @keyframes floatZzz {
      0% {
        transform: translateY(0);
        opacity: 1;
      }
      100% {
        transform: translateY(-20px);
        opacity: 0;
      }
    }
    /* Responsive styling */
    @media (max-width: 600px) {
      html, body {
        font-size: 14px; /* Reduce base font size on small screens */
      }
      .pet-name-input {
        font-size: 1.2rem;
      }
      .controls button {
        font-size: 0.9rem;
        padding: 0.6em 1em;
        flex: 1 1 calc(50% - 1em);
        max-width: calc(50% - 1em);
      }
      .zzz {
        font-size: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <!-- Include React and Babel -->
  <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  <!-- Include Babel for JSX transpilation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Our script -->
  <script type="text/babel">
    function PixelPet() {
      const { useState, useEffect, useRef } = React;
      const [seed, setSeed] = useState(Math.random() * 10000);
      const [mood, setMood] = useState('happy');
      const [evolutionStage, setEvolutionStage] = useState(0);
      const [name, setName] = useState('');
      const [species] = useState(Math.floor(Math.random() * 3));
      const [animation, setAnimation] = useState('wander');
      const [position, setPosition] = useState({ x: 50, y: 50 });
      const [direction, setDirection] = useState({ x: 1, y: 1 });
      const [colorTheme, setColorTheme] = useState(0);
      const [soundEnabled, setSoundEnabled] = useState(false);
      const [showZzz, setShowZzz] = useState(false);

      const evolutionStages = ['Egg', 'Baby', 'Teen', 'Adult'];
      const colorThemes = ['Classic', 'Pastel', 'Neon', 'Monochrome'];
      const moods = ['happy', 'sad', 'sleepy', 'energetic'];

      const containerRef = useRef(null);

      useEffect(() => {
        document.body.className = mood;
      }, [mood]);

      useEffect(() => {
        const moodAnimations = {
          happy: 'wander',
          sad: 'idle',
          sleepy: 'sleep',
          energetic: 'run',
        };
        setAnimation(moodAnimations[mood] || 'idle');

        // Show or hide the "Zzz" animation based on mood
        setShowZzz(mood === 'sleepy');
      }, [mood]);

      useEffect(() => {
        let animationFrame;
        const movePet = () => {
          setPosition(pos => {
            const containerWidth = containerRef.current.offsetWidth - 100;
            const containerHeight = containerRef.current.offsetHeight - 100;
            let newX = pos.x + direction.x * (animation === 'run' ? 4 : 1);
            let newY = pos.y + direction.y * (animation === 'run' ? 4 : 1);

            // Check horizontal boundaries
            if (newX <= 0 || newX >= containerWidth) {
              setDirection(dir => ({ ...dir, x: dir.x * -1 }));
              newX = Math.max(0, Math.min(newX, containerWidth));
            }

            // Check vertical boundaries
            if (newY <= 0 || newY >= containerHeight) {
              setDirection(dir => ({ ...dir, y: dir.y * -1 }));
              newY = Math.max(0, Math.min(newY, containerHeight));
            }

            // Randomly change direction to simulate wandering
            if (animation === 'wander' && Math.random() < 0.01) {
              setDirection({
                x: Math.random() < 0.5 ? -1 : 1,
                y: Math.random() < 0.5 ? -1 : 1,
              });
            }

            return { x: newX, y: newY };
          });

          animationFrame = requestAnimationFrame(movePet);
        };

        if (animation !== 'idle' && animation !== 'sleep') {
          animationFrame = requestAnimationFrame(movePet);
        }

        return () => cancelAnimationFrame(animationFrame);
      }, [animation, direction]);

      const safeSetGrid = (grid, x, y, value) => {
        if (y >= 0 && y < grid.length && x >= 0 && x < grid[0].length) {
          grid[y][x] = value;
        }
      };

      const safeGetGrid = (grid, x, y) => {
        if (y >= 0 && y < grid.length && x >= 0 && x < grid[0].length) {
          return grid[y][x];
        }
        return null;
      };

      const playSound = (type) => {
        if (!soundEnabled) return;
        const sounds = {
          happy: 'https://example.com/happy.mp3',
          sad: 'https://example.com/sad.mp3',
          sleepy: 'https://example.com/sleepy.mp3',
          energetic: 'https://example.com/energetic.mp3',
        };
        const audio = new Audio(sounds[type]);
        audio.play();
      };

      const generatePet = (cellSize = 8) => {
        const width = 32;
        const height = 32;
        const grid = Array(height).fill().map(() => Array(width).fill(0));

        let currentSeed = seed;
        const random = () => {
          const x = Math.sin(currentSeed++) * 10000;
          return x - Math.floor(x);
        };

        const getColors = () => {
          const hue = (colorTheme * 90 + random() * 60) % 360;
          const saturation = colorTheme === 3 ? '10%' : '70%';
          return {
            main: `hsl(${hue}, ${saturation}, ${50 + random() * 20}%)`,
            accent: `hsl(${(hue + 30) % 360}, ${saturation}, ${50 + random() * 20}%)`,
            detail: `hsl(${(hue + 60) % 360}, ${saturation}, ${50 + random() * 20}%)`
          };
        };

        const colors = getColors();

        const centerX = Math.floor(width / 2);
        const centerY = Math.floor(height / 2);

        const bodySize = 0.5 + (evolutionStage * 0.1);
        const bodyHeight = Math.floor(height * (bodySize + random() * 0.1));
        const bodyWidth = Math.floor(width * (bodySize + random() * 0.1));
        const bodyStartY = centerY - Math.floor(bodyHeight / 2);
        const bodyStartX = centerX - Math.floor(bodyWidth / 2);

        // Randomly generated features
        const features = {
          hasTail: evolutionStage >= 1 && random() > 0.5,
          hasWings: evolutionStage >= 2 && random() > 0.5,
          hasHorns: evolutionStage >= 2 && random() > 0.5,
          earType: evolutionStage >= 1 ? Math.floor(random() * 4) : -1,
          eyeType: Math.floor(random() * 4),
          mouthType: Math.floor(random() * 4),
          accessory: random() > 0.6 ? Math.floor(random() * 6) : -1,
          pattern: random() > 0.4,
        };

        // Generate body shape
        const bodyShapes = ['oval', 'round', 'square', 'blob', 'triangle', 'star', 'diamond', 'heart'];
        const bodyType = evolutionStage === 0 ? 'egg' : bodyShapes[Math.floor(random() * bodyShapes.length)];

        // Draw body
        for (let y = 0; y < bodyHeight; y++) {
          for (let x = 0; x < bodyWidth; x++) {
            let drawPixel = false;
            const nx = x - bodyWidth / 2;
            const ny = y - bodyHeight / 2;
            switch(bodyType) {
              case 'egg':
              case 'oval':
                drawPixel = (nx * nx) / ((bodyWidth / 2) ** 2) + (ny * ny) / ((bodyHeight / 2) ** 2) <= 1;
                break;
              case 'round':
                drawPixel = (nx * nx + ny * ny) <= (bodyWidth / 2) * (bodyHeight / 2) * 0.8;
                break;
              case 'square':
                drawPixel = true;
                break;
              case 'blob':
                drawPixel = random() > 0.2;
                break;
              case 'triangle':
                drawPixel = y >= x * (bodyHeight / bodyWidth) && y >= (bodyWidth - x - 1) * (bodyHeight / bodyWidth);
                break;
              case 'star':
                drawPixel = Math.abs(nx * ny) < (bodyWidth * bodyHeight) / 10;
                break;
              case 'diamond':
                drawPixel = Math.abs(nx) + Math.abs(ny) <= bodyWidth / 2;
                break;
              case 'heart':
                const a = nx / (bodyWidth / 2);
                const b = ny / (bodyHeight / 2);
                drawPixel = Math.pow(a * a + b * b - 1, 3) - a * a * b * b * b <= 0;
                break;
            }
            if (drawPixel) {
              safeSetGrid(grid, bodyStartX + x, bodyStartY + y, 1);
            }
          }
        }

        // Egg stage has no face
        if (evolutionStage > 0) {
          // Draw face
          const faceY = bodyStartY + Math.floor(bodyHeight * 0.3);
          const eyeSpacing = 2 + evolutionStage;
          const eyeX1 = centerX - eyeSpacing;
          const eyeX2 = centerX + eyeSpacing;

          // Eyes
          switch(features.eyeType) {
            case 0: // Normal eyes
              safeSetGrid(grid, eyeX1, faceY, 2);
              safeSetGrid(grid, eyeX2, faceY, 2);
              break;
            case 1: // Big eyes
              safeSetGrid(grid, eyeX1, faceY, 2);
              safeSetGrid(grid, eyeX2, faceY, 2);
              safeSetGrid(grid, eyeX1, faceY - 1, 2);
              safeSetGrid(grid, eyeX2, faceY - 1, 2);
              break;
            case 2: // Slanted eyes
              safeSetGrid(grid, eyeX1 - 1, faceY, 2);
              safeSetGrid(grid, eyeX2 + 1, faceY, 2);
              break;
            case 3: // Closed eyes
              safeSetGrid(grid, eyeX1, faceY, 2);
              safeSetGrid(grid, eyeX1 + 1, faceY, 2);
              safeSetGrid(grid, eyeX2 - 1, faceY, 2);
              safeSetGrid(grid, eyeX2, faceY, 2);
              break;
          }

          // Mouth
          const mouthY = faceY + 4;
          switch(features.mouthType) {
            case 0: // Smile
              safeSetGrid(grid, centerX - 1, mouthY, 3);
              safeSetGrid(grid, centerX, mouthY + 1, 3);
              safeSetGrid(grid, centerX + 1, mouthY, 3);
              break;
            case 1: // Frown
              safeSetGrid(grid, centerX - 1, mouthY + 1, 3);
              safeSetGrid(grid, centerX, mouthY, 3);
              safeSetGrid(grid, centerX + 1, mouthY + 1, 3);
              break;
            case 2: // Open mouth
              safeSetGrid(grid, centerX - 1, mouthY, 3);
              safeSetGrid(grid, centerX, mouthY, 3);
              safeSetGrid(grid, centerX + 1, mouthY, 3);
              break;
            case 3: // O mouth
              safeSetGrid(grid, centerX, mouthY, 3);
              safeSetGrid(grid, centerX, mouthY + 1, 3);
              break;
          }

          // Ears
          const earY = bodyStartY - 2;
          switch(features.earType) {
            case 0: // Pointy ears
              safeSetGrid(grid, centerX - 3, earY, 1);
              safeSetGrid(grid, centerX + 3, earY, 1);
              break;
            case 1: // Round ears
              safeSetGrid(grid, centerX - 3, earY + 1, 1);
              safeSetGrid(grid, centerX + 3, earY + 1, 1);
              break;
            case 2: // Long ears
              safeSetGrid(grid, centerX - 2, earY - 1, 1);
              safeSetGrid(grid, centerX + 2, earY - 1, 1);
              safeSetGrid(grid, centerX - 2, earY, 1);
              safeSetGrid(grid, centerX + 2, earY, 1);
              break;
            case 3: // Antenna
              safeSetGrid(grid, centerX, earY - 2, 1);
              safeSetGrid(grid, centerX, earY - 1, 1);
              break;
          }

          // Horns
          if (features.hasHorns) {
            safeSetGrid(grid, centerX - 1, earY - 2, 1);
            safeSetGrid(grid, centerX + 1, earY - 2, 1);
          }

          // Wings
          if (features.hasWings) {
            for (let i = 0; i < 3; i++) {
              safeSetGrid(grid, centerX - Math.floor(bodyWidth / 2) - i, centerY + i, 1);
              safeSetGrid(grid, centerX + Math.floor(bodyWidth / 2) + i, centerY + i, 1);
            }
          }

          // Tail
          if (features.hasTail) {
            for (let i = 0; i < 4; i++) {
              safeSetGrid(grid, centerX, bodyStartY + bodyHeight + i, 1);
            }
          }

          // Accessories
          if (features.accessory !== -1) {
            const accessoryY = bodyStartY - 4;
            switch(features.accessory) {
              case 0: // Hat
                for (let x = -2; x <= 2; x++) {
                  safeSetGrid(grid, centerX + x, accessoryY, 4);
                }
                safeSetGrid(grid, centerX, accessoryY - 1, 4);
                break;
              case 1: // Bow
                safeSetGrid(grid, centerX - 2, accessoryY, 4);
                safeSetGrid(grid, centerX + 2, accessoryY, 4);
                safeSetGrid(grid, centerX, accessoryY + 1, 4);
                break;
              case 2: // Glasses
                for (let x = eyeX1 - 1; x <= eyeX2 + 1; x++) {
                  safeSetGrid(grid, x, faceY, 4);
                }
                safeSetGrid(grid, centerX, faceY, 4);
                break;
              case 3: // Scarf
                for (let x = -3; x <= 3; x++) {
                  safeSetGrid(grid, centerX + x, faceY + 5, 4);
                }
                break;
              case 4: // Necklace
                safeSetGrid(grid, centerX - 1, faceY + 6, 4);
                safeSetGrid(grid, centerX, faceY + 6, 4);
                safeSetGrid(grid, centerX + 1, faceY + 6, 4);
                break;
              case 5: // Flower
                safeSetGrid(grid, centerX - 3, accessoryY + 1, 4);
                safeSetGrid(grid, centerX - 3, accessoryY, 4);
                safeSetGrid(grid, centerX - 4, accessoryY + 1, 4);
                safeSetGrid(grid, centerX - 2, accessoryY + 1, 4);
                break;
            }
          }

          // Patterns or spots
          if (features.pattern) {
            for (let i = 0; i < 15; i++) {
              const x = bodyStartX + Math.floor(random() * bodyWidth);
              const y = bodyStartY + Math.floor(random() * bodyHeight);
              if (safeGetGrid(grid, x, y) === 1) {
                safeSetGrid(grid, x, y, 5);
              }
            }
          }
        }

        return (
          <svg
            viewBox={`0 0 ${width * cellSize} ${height * cellSize}`}
            width={width * cellSize}
            height={height * cellSize}
            style={{
              position: 'absolute',
              left: position.x,
              top: position.y,
              transform: direction.x === -1 ? 'scaleX(-1)' : 'scaleX(1)',
            }}
          >
            {grid.map((row, y) =>
              row.map((cell, x) =>
                cell ? (
                  <rect
                    key={`${x}-${y}`}
                    x={x * cellSize}
                    y={y * cellSize}
                    width={cellSize}
                    height={cellSize}
                    fill={
                      cell === 1 ? colors.main :
                      cell === 2 ? 'black' :
                      cell === 3 ? 'black' :
                      cell === 4 ? colors.accent :
                      cell === 5 ? colors.detail :
                      'black'
                    }
                  />
                ) : null
              )
            )}
          </svg>
        );
      };

      return (
        <div className="app-container" ref={containerRef}>
          <input
            placeholder="Name your pet"
            value={name}
            onChange={e => setName(e.target.value)}
            className="pet-name-input"
          />
          <div className="pet-container">
            {generatePet()}
            {showZzz && (
              <div
                className="zzz"
                style={{
                  position: 'absolute',
                  left: position.x + 20, // Adjust as needed
                  top: position.y - 30,  // Adjust as needed
                }}
              >
                Zzz...
              </div>
            )}
          </div>
          <div className="controls">
            <button onClick={() => { setSeed(Math.random() * 10000); playSound('happy'); }}>
              New Pet
            </button>
            <button onClick={() => {
              const newMood = moods[(moods.indexOf(mood) + 1) % moods.length];
              setMood(newMood);
              playSound(newMood);
            }}>
              Mood
            </button>
            <button
              onClick={() => { setEvolutionStage(prev => Math.min(prev + 1, evolutionStages.length - 1)); playSound('happy'); }}
              disabled={evolutionStage === evolutionStages.length - 1}
            >
              Evolve
            </button>
            <button
              onClick={() => { setEvolutionStage(prev => Math.max(prev - 1, 0)); playSound('sad'); }}
              disabled={evolutionStage === 0}
            >
              Devolve
            </button>
            <button onClick={() => setColorTheme((colorTheme + 1) % colorThemes.length)}>
              {colorThemes[colorTheme]}
            </button>
            <button onClick={() => setSoundEnabled(!soundEnabled)}>
              {soundEnabled ? 'Sound On' : 'Sound Off'}
            </button>
          </div>
        </div>
      );
    }

    // Render the component
    ReactDOM.render(<PixelPet />, document.getElementById('root'));
  </script>
</body>
</html>
